var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Installation-of-Julia","page":"Installation","title":"Installation of Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download and install: https://julialang.org/downloads/.","category":"page"},{"location":"installation/#Installation-of-Tapestree","page":"Installation","title":"Installation of Tapestree","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open julia and type the following","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"Tapestree\")","category":"page"},{"location":"man/insane/cfbd/#Constant-fossilized-birth-death-process-(CFBD)","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death process (CFBD)","text":"","category":"section"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"We now consider that species have an instantaneous rate of being sampled as fossils, psi, besides the constant rate of speciation lambda and extinction mu.","category":"page"},{"location":"man/insane/cfbd/#Simulations","page":"Constant fossilized birth-death","title":"Simulations","text":"","category":"section"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"To simulate under the CFBD model, say, for a period of 10, with speciation rate of 05, extinction rate of 03, and fossilization rate of 04, one can use","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"tr = sim_cfbd(10.0, 0.5, 0.3, 0.4)","category":"page"},{"location":"man/insane/cfbd/#Inference","page":"Constant fossilized birth-death","title":"Inference","text":"","category":"section"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"To perform inference on the CFBD model, we can use","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"r, tv = insane_cfbd(tree,\n                    nburn    = 1_000,\n                    niter    = 50_000,\n                    nthin    = 50, \n                    ofile    = \"<directory>\",\n                    λ_prior  = (1.0, 1.0),\n                    μ_prior  = (1.0, 1.0),\n                    ψ_prior  = (1.0, 1.0),\n                    survival = true,\n                    tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"where we now have a Gamma prior for the speciation lambda, extinction mu and fossilization rates psi, and we can also specify if we want to condition on survival of the process with survival.","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"note: Note\nthe tree object must be of type sTf_label Insane tree and model input/output, which is the automatic type when reading a tree with read_newick.","category":"page"},{"location":"man/insane/cfbd/#Episodic-fossilized-birth-death-process-(eFBD)","page":"Constant fossilized birth-death","title":"Episodic fossilized birth-death process (eFBD)","text":"","category":"section"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"We now consider that the fossilization rate can vary through time in piece-wise constant fashion, for instance, for different stratigraphic epochs. The periods are not inferred but must instead be pre-defined.","category":"page"},{"location":"man/insane/cfbd/#Simulations-2","page":"Constant fossilized birth-death","title":"Simulations","text":"","category":"section"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"To simulate under the eFBD model, for a period of, say, 10, with speciation rate of 05, extinction rate of 03, and fossilization rates of 04 01 08 at periods (10 7), (7 3) and (3 0):","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"tr = sim_cfbd(10.0, 0.5, 0.3, [0.4, 0.1, 0.8], [7.0, 3.0])","category":"page"},{"location":"man/insane/cfbd/#Inference-2","page":"Constant fossilized birth-death","title":"Inference","text":"","category":"section"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"To perform inference on the eFBD model, we input the times defining the periods for different fossilization rates ψ_epoch. If we define the periods used above for simulation, we can use","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"r, tv = insane_cfbd(tree,\n                    nburn    = 1_000,\n                    niter    = 50_000,\n                    nthin    = 50, \n                    ofile    = \"<directory>\",\n                    λ_prior  = (1.0, 1.0),\n                    μ_prior  = (1.0, 1.0),\n                    ψ_prior  = (1.0, 1.0),\n                    ψ_epoch  = [7.0, 3.0],\n                    survival = true,\n                    tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/cfbd/#Adding-external-fossil-occurrences","page":"Constant fossilized birth-death","title":"Adding external fossil occurrences","text":"","category":"section"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"Finally, one can incorporate known fossil occurrences that are not included in the empirical tree. For instance, we might know of 4 fossil occurrences for a given species, but only one of them is represented in the empirical tree. Adding the other 3 occurrences might be desirable to better inform the fossilization rates, which has cascading effects on inferred speciation and extinction.","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"Given the eFBD model assumptions, this additional fossil occurrences act as sampled ancestors, and their position on the tree does not matter (since we assume that all lineages at a given period share the same fossilization rate). Thus, we only need to input an Integer vector specifying the number of additional fossil occurrences per period. Following the example above, suppose we have 3, 2 and 5 additional occurrences per period, which we would specify in the f_epoch argument, as follows","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"r, tv = insane_cfbd(tree,\n                    nburn    = 1_000,\n                    niter    = 50_000,\n                    nthin    = 50, \n                    ofile    = \"<directory>\",\n                    λ_prior  = (1.0, 1.0),\n                    μ_prior  = (1.0, 1.0),\n                    ψ_prior  = (1.0, 1.0),\n                    ψ_epoch  = [7.0, 3.0],\n                    f_epoch  = [3, 2, 5],\n                    survival = true,\n                    tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/cfbd/","page":"Constant fossilized birth-death","title":"Constant fossilized birth-death","text":"Full documentation","category":"page"},{"location":"man/insane/cfbd/#Tapestree.INSANE.sim_cfbd","page":"Constant fossilized birth-death","title":"Tapestree.INSANE.sim_cfbd","text":"sim_cfbd(t::Float64, λ::Float64, μ::Float64, ψ::Float64)\n\nSimulate a constant fossilized birth-death iTree of height t with speciation rate λ, extinction rate μ and fossilization rate ψ.\n\n\n\n\n\nsim_cfbd(t  ::Float64,\n         λ  ::Float64,\n         μ  ::Float64,\n         ψ  ::Vector{Float64},\n         ψts::Vector{Float64})\n\nSimulate a constant fossilized birth-death iTree of height t with speciation rate λ, extinction rate μ and a vector of fossilization rates ψ.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/cfbd/#Tapestree.INSANE.insane_cfbd","page":"Constant fossilized birth-death","title":"Tapestree.INSANE.insane_cfbd","text":"insane_cfbd(tree    ::sTf_label;\n            λ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n            μ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n            ψ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n            ψ_epoch ::Vector{Float64}       = Float64[],\n            f_epoch ::Vector{Int64}         = Int64[0],\n            niter   ::Int64                 = 1_000,\n            nthin   ::Int64                 = 10,\n            nburn   ::Int64                 = 200,\n            nflush  ::Int64                 = nthin,\n            ofile   ::String                = string(homedir(), \"/cfbd\"),\n            ϵi      ::Float64               = 0.4,\n            λi      ::Float64               = NaN,\n            μi      ::Float64               = NaN,\n            ψi      ::Float64               = NaN,\n            pupdp   ::NTuple{4,Float64}     = (0.01, 0.01, 0.01, 0.1),\n            survival::Bool                  = true,\n            prints  ::Int64                 = 5,\n            mxthf   ::Float64               = Inf,\n            tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for constant fossilized birth-death.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/io/#Insane-input-and-structures","page":"Input and structures","title":"Insane input & structures","text":"","category":"section"},{"location":"man/insane/io/#Insane-tree-and-model-input/output","page":"Input and structures","title":"Insane tree and model input/output","text":"","category":"section"},{"location":"man/insane/io/#Insane-trees","page":"Input and structures","title":"Insane trees","text":"","category":"section"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"INSANE uses different types of trees, but all are recursive structures. All trees have at least three fields: ","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"d1 which corresponds to the left daughter (either another tree structure or nothing if it is a tip).\nd2 which corresponds to the right daughter (also either another tree structure or nothing if it is not a bifurcation).\ne a decimal number specifying the edge length of the tree.","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"For all tree output from simulations and inference (all expect labelled trees):","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"fx a Boolean stating if tree is fixed or not. That is, if it corresponds to a sampled (fx = true) or unsampled (fx = false) lineage.","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"For all trees that allow for extinction:","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"iμ a Boolean stating if tree is extinct (iμ = true) or not (iμ = false).","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"For fossil trees:","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"iψ a Boolean stating if tree is fossil (iψ = true) or not (iψ = false).","category":"page"},{"location":"man/insane/io/#Insane-simple-trees-(sT-and-sTf)","page":"Input and structures","title":"Insane simple trees (sT & sTf)","text":"","category":"section"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"sT_label: is a simple labelled tree, and is the one required as input to perform inference. \nsTf_label: is a simple fossil labelled tree, and is the one required as input to perform inference for fossilized birth-death models. ","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"They have the additional field l for label.","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"note: Note\nAll other model specific tree types can be converted to sT_label by using the latter as a function: tree = sT_label(tree_of_other_type). For fossil trees as well by using tree = sTf_label(fossil_tree_of_other_type).","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"sTpb: is a simple pure-birth tree for the constant pure-birth (Yule) model.\nsTbd: is a simple birth-death tree for the constant birth-death model.\nsTfbd: is a simple fossil birth-death tree for the constant and episodic fossilized birth-death models.","category":"page"},{"location":"man/insane/io/#Insane-BDD-and-FBDD-trees-(iT)","page":"Input and structures","title":"Insane BDD & FBDD trees (iT)","text":"","category":"section"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"All iT trees specify to birth-death diffusion trees with different extinction assumptions and all hold the following extra fields:","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"dt a decimal specifying the time step of the GBM discretization.\nfdt a decimal specifying the final time step of the GBM discretization.\nlλ an array specifying the Brownian motion evolution of log-speciation rates.","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"And have the following concrete types:","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"iTpb, iTce and iTct: are BDD trees with no-extinction (pure-birth), constant extinction and constant turnover, respectively.\niTbd: the full BDD tree.\niTfbd: for the fossil BDD tree.","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"These last two have the additional field lμ:  an array specifying the Brownian motion evolution of log-extinction rates.","category":"page"},{"location":"man/insane/io/#Insane-DBM-trees-(sTxs)","page":"Input and structures","title":"Insane DBM trees (sTxs)","text":"","category":"section"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"dt a decimal specifying the time step of the GBM discretization.\nfdt a decimal specifying the final time step of the GBM discretization.\nxv an array specifying the Brownian motion evolution of traits.\nlσ2 an array specifying the Geometric Brownian motion evolution of rates.","category":"page"},{"location":"man/insane/io/#Reading-and-saving-newick-trees","page":"Input and structures","title":"Reading and saving newick trees","text":"","category":"section"},{"location":"man/insane/io/#Extant-only-trees","page":"Input and structures","title":"Extant only trees","text":"","category":"section"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"Tapestree can read files in the simple newick format using the read_newick function:","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"tree = read_newick(joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"tree_5.tre\"))","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"note: Note\n","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"This tree has type sT_label, which stands for simple labelled tree. You can check this using","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"    typeof(tree)\n    ```\n\n#### Trees with fossils\n\nTapestree reads fossilized birth-death trees in newick format using the `read_newick` function, as above, but specifying as second argument `true`:","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"julia tree = readnewick(joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"tree6.tre\"), true)","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"\nIn addition, because of rounding errors, a very recent fossil tip might actually be labelled as an extant tip or vice-versa. To control for the time from which extant species are differentiated from fossil tip ones, the argument `ne` can be used:","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"julia tree = readnewick(joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"tree6.tre\"), true, ne = 0.1)","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"\nTapestree can also write trees using `write_newick`","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"julia write_newick(tree, \"<directory>\")","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"\n!!! note\n    Only `*_label` trees (_i.e._, `sT_label` & `sTf_label`) have labels. So if you want to save a DA tree with the original tip labels plus new names to the data augmented trees, you first will have to create a labelled tree from the `DA_tree` and the loaded labelled `tree` and then save it:\n    ```julia\n    write_newick(sT_label(DA_tree, tree), \"<directory>\")\n    ```\n\n### Reading and saving model output\n\nAll models can return and/or save the output by writing directly to a file on the fly and within the Julia session when the model finishes. There are two outputs:\n\n1. The governing parameters trace, which is saved as a `.log` file and returned as the first object once the algorithm finished. These can be conveniently read in the Tracer software [https://github.com/beast-dev/tracer/releases/tag/v1.7.2])https://github.com/beast-dev/tracer/releases/tag/v1.7.2).\n2. The DA trees as a tree vector which are saved as a `.txt` file (of the same name as the `.log`) and returned as the second object once the algorithm finished. \n\nThe DA trees written in the insane-specific `.txt` file can be read using the `iread()` function, which only needs the specific file directory as input, but also accepts an optional (keyword) argument `ix` that indicates the specific tree iterations to read, as an `OrdinalRange` object. For instance, to read only the first ``50`` trees, one can use `iread(\"<directory to txt>\", ix = 1:50`. To read only the trees every ``10`` iterations from the ``100`` to ``400`` sampled, one can use `ix = 100:10:400`, and so on. This can be helpful to avoid high computation costs of reading very large files.\n\nYou can save any individual or vector of insane trees using the `iwrite()` function: `iwrite(trees, \"<directory>\")`, which can be read by `Tapestree`. For portability, you can also save the DA trees as nexus files where nodes have been annotated with the vector of rates using `write_nexus(trees, tree, \"<directory>\")`, where trees is the tree vector and tree is the original labelled tree (_i.e._, the one you used as input into an insane model).\n\n\n## Insane models\n\n\n### Tree input\n\nAll inference functions require a phylogenetic tree of type `sT_label` or `sTf_label`, that is, a simple labelled tree. This is the default object type when using the `read_newick` function. However, when using simulations from models or `iread`, the resulting type is specific to the model (for computational efficiency). One can easily create a tree of type `sT_label` or `sTf_label` from any other tree by using `sT_label(tree)` and `sTf_label(tree)`, respectively. The output can then be used to perform inference.\n\n\n### Common (keyword) arguments across all insane inference models\n\n* `nburn`: specifies the number of iterations to discard as burn-in.\n* `niter`: specifies the number of MCMC iterations. \n* `nthin`: specifies the iteration frequency at which to save the parameters **in the julia session** (_i.e._,`nthin = 2` specifies saving every 2 iterations), \n* `nflush`: specifies the frequency at which to save **to file**. \n* `ofile`: specifies the directory where the results will be written. \n* `tρ`: controls the sampling fraction and receives a `Dictionary` as input, with a `String` key pointing to a `Float64` number (_i.e._, `Dict{String, Float64}`). If the dictionary is of length 1 with an empty string, then the insane sets this as a the global sampling fraction. For example, to set a sampling fraction of `0.6`, one show input `tρ = Dict(\"\" => 0.6)`. Most times, however, sampling fraction is not uniform across the tree, but rather some part so the tree is more heavily sampled than others, to accommodate these variability, you can input a dictionary of the same length as the number of tips in the tree, where the dictionary key string is the tip label pointing to the specific sampling fraction value. For example, for two tips, named `tip_1` and `tip_2`, one could input `tρ = Dict(\"tip_1\" => 0.5, \"tip_2\" => 0.3)`. Make sure to specify all tips when assigning different sampling fractions across the tips, even ones with `1.0`. \n* `prints`: specifies the number of seconds to refresh the progress meter.\n* `survival`: For those modesl with extinction, `true` or `false` if to condition the likelihood on survival.\n\n\n\nFull documentation","category":"page"},{"location":"man/insane/io/","page":"Input and structures","title":"Input and structures","text":"@docs readnewick writenewick iread iwrite write_nexus ```","category":"page"},{"location":"man/insane/processing/#Insane-tree-data-access-and-processing-functions","page":"Processing","title":"Insane tree data access and processing functions","text":"","category":"section"},{"location":"man/insane/processing/#Basic-tree-information","page":"Processing","title":"Basic tree information","text":"","category":"section"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Basic information about the tree, such as the number tips, the number of extinct tips, the number of fossils, the tree height (duration of the tree) and the tree length (sum of all branch lengths) can be performed using, respectively:","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"ntips(tree)\nntipsextinct(tree)\nnfossils(tree)\ntreeheight(tree)\ntreelength(tree)","category":"page"},{"location":"man/insane/processing/#Tree-vector-statistics","page":"Processing","title":"Tree vector statistics","text":"","category":"section"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Julia makes it simple to look at statistics across a vector of trees. For example, using the package Statistics, we can estimate the average number of extinct species on tree vector tv by simply:","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"using Statistics \n\nmean(ntipsextinct, tv)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"See the documentation of mean for more details, but basically, mean, and many other functions in Julia allow to perform a undefined function on each element before calculating the mean. In this case, we are estimating the number of extinct tips in each tree in tv, and then averaging over them.","category":"page"},{"location":"man/insane/processing/#Tree-labels-and-obtaining-subtrees","page":"Processing","title":"Tree labels and obtaining subtrees","text":"","category":"section"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"For labelled trees, one can extract the tip labels using tiplabels. Moreover we can create subclades based on a vector of tips, where the subclade will be the minimum tree that has all the tips. For example, for a vector tip_vector holding Strings that correspond to the tip labels in the tree of type sT_label, we can use","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"subclade(tree, tip_vector)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"However, most time we want to extract subclades of other types of trees. Since these do not hold label information but should be ordered in the same order as the sT_label tree, one has to use both. ","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"warning: Warning\nif you change the order of either the sT_label tree or the single of vector of trees of other types, this will not work. ","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Thus, if we want a the subclades that have the tips in tip_vector, we can use","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"subclade(tv, tree, tip_vector, true)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"where the last argument states if returning the stem or crown tree.","category":"page"},{"location":"man/insane/processing/#Lineage-and-Diversity-through-time-(LTT-and-DTT)","page":"Processing","title":"Lineage and Diversity through time (LTT & DTT)","text":"","category":"section"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"One can also estimate the Lineage Through Time (LTT), or, for a data augmented tree (or a vector of trees), the Diversity Through Time (DTT) using ","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"ltt(tree)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"To be clear, the LTT is usually used to describe the accumulation of reconstructed lineages (those that have been sampled) while DTT is used to describe estimated diversity (sampled and unsampled lineages). Thus, the result is either LTT or DTT simply depending on the tree you use as input.","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"We can also estimate the ltt for a tree vector tv using","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"ltt(tv)","category":"page"},{"location":"man/insane/processing/#Trees-with-diffusion-information-(*e.g.*,-BDD,-FBDD,-DBM)","page":"Processing","title":"Trees with diffusion information (e.g., BDD, FBDD, DBM)","text":"","category":"section"},{"location":"man/insane/processing/#Estimating-posterior-average-rates-along-the-tree","page":"Processing","title":"Estimating posterior average rates along the tree","text":"","category":"section"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Of particular interest is the estimation of posterior average rates along the reconstructed tree. Since the data augmented (unsampled) lineages change between different iterations of the algorithm, we obtain lineage-specific instantaneous rate distributions only for the reconstructed (observed) part of the trees (the tree we used as input). Consequently, we first need to remove the data augmented lineages from all the trees in the posterior tree vector:","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"tv0 = remove_unsampled(tv)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"We can then estimate the average tree using","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"tm = imean(tv0)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"We can also estimate any quantile tree, for instance, for the 025 quantile tree:","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"t025 = iquantile(tv0, 0.25)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Clearly, these resulting trees can then be further scrutinized as with any other tree in INSANE.","category":"page"},{"location":"man/insane/processing/#Other-data-access-and-averaging-functions","page":"Processing","title":"Other data access and averaging functions","text":"","category":"section"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"If one wants to obtain the range (i.e., extrema) of the output of function f on tree, for example, the maximum and minimum speciation rates:","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"irange(tree, b)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"If one wants to sample, recursively, some function at regular intervals along a tree, one can use sample. For example if we want to sample speciation rates every 01 time units, we can use","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"sample(tv, b, 0.1)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"note: Note\nHere we are sampling along each branch of the tree in recursive order, not sampling across lineages through time. ","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"If we would like to extract an array across lineages in a given tree of the output of function f, we would use time_rate. For example, if we want the cross-lineage extinction rates of a tree of type iTbd sampled every 05 time units, we would use","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"time_rate(tv, d, 0.5)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"which returns a vector of vectors, where each element is a time holding the rates (in this case extinction rates) of all contemporary lineages at that time.","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Finally, a convenience wrapper to extract information recursively from a tree is trextract. For example, if we want all branch lengths for a tree, we can use","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"trextract(tree, e)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Below are some functions to obtain data from trees.","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Full documentation","category":"page"},{"location":"man/insane/processing/#Tapestree.INSANE.tiplabels","page":"Processing","title":"Tapestree.INSANE.tiplabels","text":"tiplabels(tree::T) where {T <: Tlabel}\n\nReturns tip labels for sT_label and sTf_label.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.ntips","page":"Processing","title":"Tapestree.INSANE.ntips","text":"ntips(tree::T) where {T <: iTree}\n\nReturn the number of tip nodes for tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.ntipsalive","page":"Processing","title":"Tapestree.INSANE.ntipsalive","text":"ntipsalive(tree::T) where {T <: iTree}\n\nReturn the number of alive nodes for tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.ntipsextinct","page":"Processing","title":"Tapestree.INSANE.ntipsextinct","text":"ntipsextinct(tree::T) where {T <: iTree}\n\nReturn the number of extinct nodes for tree.\n\n\n\n\n\nntipsextinct(Ξ::Vector{T}) where {T <: iTree}\n\nReturn the number of extinct nodes in Ξ.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.treeheight","page":"Processing","title":"Tapestree.INSANE.treeheight","text":"treeheight(tree::T) where {T <: iTree}\n\nReturn the tree height of tree.\n\n\n\n\n\ntreeheight(tree::T) where {T <: iTf}\n\nReturn the tree height of tree.\n\n\n\n\n\ntreeheight(tree::T, nd::Int64) where {T <: iTree}\n\nReturn the tree height of tree.\n\n\n\n\n\ntreeheight(tree::T, nd::Int64) where {T <: iTf}\n\nReturn the tree height of tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.treelength","page":"Processing","title":"Tapestree.INSANE.treelength","text":"treelength(tree::T) where {T <: iTree}\n\nReturn the branch length sum of tree.\n\n\n\n\n\ntreelength(tree::T, ets::Vector{Float64})  where {T <: iTf}\n\nReturn the branch length sum of tree at different epochs, initialized at l.\n\n\n\n\n\ntreelength(Ξ::Vector{T}) where {T <: iTree}\n\nReturn the branch length sum of Ξ.\n\n\n\n\n\ntreelength(Ξ  ::Vector{T},\n           ets::Vector{Float64},\n           bst::Vector{Float64},\n           eix::Vector{Int64})  where {T <: iTf}\n\nReturn the branch length sum of tree at different epochs, initialized at l.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.ltt","page":"Processing","title":"Tapestree.INSANE.ltt","text":"ltt(tree::T) where {T <: iTree}\n\nReturns number of species through time.\n\n\n\n\n\nltt(tree::Vector{T}) where {T <: iTree}\n\nReturns number of species through time for a tree vector.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.iscrowntree","page":"Processing","title":"Tapestree.INSANE.iscrowntree","text":"iscrowntree(tree::T) where {T <: iTree}\n\nReturn if the tree is a crown tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.irange","page":"Processing","title":"Tapestree.INSANE.irange","text":"irange(tree::T, f::Function) where {T <: iTree}\n\nReturn the extrema of the output of function f on tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.time_rate","page":"Processing","title":"Tapestree.INSANE.time_rate","text":"time_rate(tree::T, f::Function, δt::Float64) where {T <: iT}\n\nExtract values from f function at times sampled every δt across the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.trextract","page":"Processing","title":"Tapestree.INSANE.trextract","text":"trextract(tree::iTree, f::Function)\n\nPerform function f in each recursive tree in tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.subclade","page":"Processing","title":"Tapestree.INSANE.subclade","text":"subclade(tree::iTree, ix::Int64)\n\nReturn the minimum stem subclade according to recursive position ix.\n\n\n\n\n\nsubclade(trees::Vector{T}, \n              ltree::sT_label, \n              tips ::Vector{String},\n              stem ::Bool) where {T <: iTree}\n\nReturn the minimum subclade that includes tip labels in tips.\n\n\n\n\n\nsubclade(tree::sT_label, tips::Vector{String})\n\nReturn the minimum subclade that includes tip labels in tips.\n\n\n\n\n\nsubclade(tree::iTree, \n         ltree::sT_label, \n         tips ::Vector{String}, \n         stem ::Bool)\n\nReturn the minimum subclade that includes tip labels in tips.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.lλ","page":"Processing","title":"Tapestree.INSANE.lλ","text":"lλ(tree::T) where {T <: iT}\n\nReturn pendant edge.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.lμ","page":"Processing","title":"Tapestree.INSANE.lμ","text":"lμ(tree::iTbdU)\n\nReturn pendant edge.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.e","page":"Processing","title":"Tapestree.INSANE.e","text":"e(id::iB)\n\nReturn initial absolute time.\n\n\n\n\n\ne(tree::T) where {T <: iTree}\n\nReturn edge length.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Insane-tree-manipulation-functions","page":"Processing","title":"Insane tree manipulation functions","text":"","category":"section"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Two important manipulation functions are, first to be able to remove extinct lineages, which can be performed on a tree or a tree vector using","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"remove_extinct(tree)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Similarly, as shown above, one can remove the unsampled lineages (all the data augmented lineages) on a single or vector of trees using","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"remove_unsampled(tree)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"note: Note\nremove_extinct and remove_unsampled are different. First, when performing simulations, the tree is not fixed, which means that if you run remove_unsampled, you will remove the tree. You would have to fix the tree before, which can be done using fixtree!(tree). Also, if sampling fraction is not 1, remove_unsampled will also remove lineages alive that were not sampled, while remove_extinct will only remove those lineages extinct.","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"For fossil trees, one can remove all fossils using","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"remove_fossils(tree)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"or make a given tree a fossil by using","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"fossilize!(tree)","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"which will only make fossil that specific tree (not the recursive daughters).","category":"page"},{"location":"man/insane/processing/","page":"Processing","title":"Processing","text":"Full documentation","category":"page"},{"location":"man/insane/processing/#Tapestree.INSANE.reorder!","page":"Processing","title":"Tapestree.INSANE.reorder!","text":"reorder(tree::T) where {T <: iTree}\n\nReorder order of daughter branches according to number of tips, with daughter 1 always having more than daughter 2.\n\n\n\n\n\nreorder!(tree::T, treeda::D) where {T <: iTree, D <: iTree}\n\nReorder order of daughter branches for both trees, following tree first, according to number of tips, with daughter1 always having more than daughter 2.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.rm_stem!","page":"Processing","title":"Tapestree.INSANE.rm_stem!","text":"rm_stem(tree::T) where {T <: iTree}\n\nRemoves stem branch.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.fixtree!","page":"Processing","title":"Tapestree.INSANE.fixtree!","text":"fixtree!(tree::T) where {T <: iTree}\n\nFix all tree.\n\n\n\n\n\nfixtree!(tree::T) where {T <: iTf}\n\nFix all tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.remove_extinct","page":"Processing","title":"Tapestree.INSANE.remove_extinct","text":"remove_extinct(tree::T) where {T <: iTree}\n\nRemove extinct tips from iTce.\n\n\n\n\n\nremove_extinct(treev::Vector{T}) where {T <: iTree}\n\nRemove extinct taxa for a vector of trees.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/processing/#Tapestree.INSANE.remove_unsampled","page":"Processing","title":"Tapestree.INSANE.remove_unsampled","text":"remove_unsampled(tree::T) where {T <: iTree}\n\nRemove unsampled tips from iTpb.\n\n\n\n\n\nremove_unsampled(treev::Vector{T}) where {T <: iTree}\n\nRemove unsampled taxa for a vector of trees.\n\n\n\n\n\n","category":"function"},{"location":"quick_start/#Quick-runs","page":"Quick start","title":"Quick runs","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"You can quickly run any of the models in Tapestree.jl by following these minimal tutorials under mostly default parameters. To conduct thorough analyses, add options, use additional models, or several other capabilities (such as plotting) please read the Manual.","category":"page"},{"location":"quick_start/#INSANE-models-using-Bayesian-Data-augmentation-(DA)","page":"Quick start","title":"INSANE models using Bayesian Data augmentation (DA)","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"INSANE models output two files, a .log file that saves the standard MCMC parameters trace (can be read in by Tracer link) and a .txt file with the data augmented (DA) trees that can be read using iread() function. These two vectors (named below r and tv consistently for the parameter Matrix and the DA tree vector) are also returned by the function and kept in memory on the active Julia sessions. Moreover, the DA tree vector can be exported as an annotated nexus file using write_nexus(), allowing interoperability with other phylogenetic software.","category":"page"},{"location":"quick_start/#Reading-a-newick-tree","page":"Quick start","title":"Reading a newick tree","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To read a tree in newick format you can just use","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"tree = read_newick(\"<tree file directory in newick format>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"You can plot this tree by loading the Plots package and then doing","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(tree)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f15)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"note: Note\nThis is the tree_5.tre in the Tapestree data directory.","category":"page"},{"location":"quick_start/#Diversification-(birth-death)-models","page":"Quick start","title":"Diversification (birth-death) models","text":"","category":"section"},{"location":"quick_start/#Constant-Birth-Death-(CBD):","page":"Quick start","title":"Constant Birth-Death (CBD):","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Tapestree\n\ntree = read_newick(\"<tree file directory in newick format>\")\n\nr, tv = insane_cbd(tree,\n                   niter = 100_000,\n                   nthin = 1_000,\n                   ofile = \"<out files directory>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"note: Note\nFor the following I used here the 5 tip tree tree_5.tre in the `data directory of Tapestree.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"The tv is a vector of all data augmented (DA) posterior trees. You can plot one of them doing","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(tv[1])","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f1)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"You can discern the data augmented lineages by using showda = true","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(tv[1], showda = true, linewidth = 3.0)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f2)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"You can estimate and plot the diversity through time (DTT) every 0.1 time units by doing","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(ltt(tv), 0.1)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f3)","category":"page"},{"location":"quick_start/#Birth-Death-Diffusion-(BDD):","page":"Quick start","title":"Birth-Death Diffusion (BDD):","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Tapestree\n\ntree = read_newick(\"<tree file directory in newick format>\")\n\nr, tv = insane_gbmbd(tree,\n                     niter = 100_000,\n                     nthin = 1_000,\n                     ofile = \"<out files directory>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"info: Info\nFor no extinction use insane_gbmpb, for constant extinction use insane_gbmce, for constant turnover use insane_gbmct.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"note: Note\nFor the following I used here the 5 tip tree tree_5.tre in the data directory of Tapestree.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To estimate the posterior average speciation and extinction rates along the tree, we first remove the DA lineages","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"tv0 = remove_unsampled(tv)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"And then estimate the average","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"tm = imean(tv0)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"You can plot the tree \"painted\" by the latent speciation rates","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(tm, birth)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f4)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Or the extinction rates","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(tm, death)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f5)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"We can also plot, say, the cross-lineage average speciation rate","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(birth, 0.1, tv)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f14)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"One can save this tree vector as an annotated nexus file that can be read by other phylogenetic software","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"write_nexus(tv, tree, \"<output directory>\")","category":"page"},{"location":"quick_start/#Constant-Fossilized-Birth-Death-(CFBD):","page":"Quick start","title":"Constant Fossilized Birth-Death (CFBD):","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Tapestree\n\ntree = read_newick(\"<tree file directory in newick format>\", true)\n\nr, tv = insane_cfbd(tree,\n                    niter = 100_000,\n                    nthin = 1_000,\n                    ofile = \"<out files directory>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"info: Info\nto read FBD trees, you need to add true as a second argument in read_newick.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"note: Note\nFor the following I used here the 6 tip fossil tree tree_6.tre in the data directory of Tapestree.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"One can plot the input tree","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(tree)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f6)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"And compare it to one randomly chosen posterior data augmented trees","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(rand(tv), showda = true, linewidth = 3)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f7)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Tapestree allows for piece-wise constant rates of preservation that change at times specified by the user (\"episodic FBD\"). For example, if the input is a tree with, say, tree height = 30 (the depth of the tree), we could want to specify that the rates of fossilization are different between, say, the periods (30 21), (2109), and (090).","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For this it suffices to include a (Float64) vector of times where the fossilization rate, psi, is allowed to change in the ψ_epoch argument","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"r, tv = insane_cfbd(tree,\n                    niter   = 100_000,\n                    nthin   = 1_000,\n                    ψ_epoch = [2.1, 0.9],\n                    ofile   = \"<out files directory>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Finally, it might be desirable to incorporate fossil occurrences of species in the empirical tree that were not included. For instance, we might have a species represented only by one fossil occurrence as a tip in the tree, but we have information of some other fossil occurrences of this species. Including this information will better inform the fossilization rate.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To continue the example above, suppose that we have 2, 1 and 3 additional fossil occurrences for species represented in our tree, for the three periods. To include this information, we simply specify it in the f_epoch argument:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"r, tv = insane_cfbd(tree,\n                    niter   = 100_000,\n                    nthin   = 1_000,\n                    ψ_epoch = [2.1, 0.9],\n                    f_epoch = [2, 1, 3],\n                    ofile   = \"<out files directory>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Let's look at the diversity through time, and add also the LTT from the empirical tree for comparison","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(ltt(tv), 0.1)\nplot!(ltt(tree), linewidth = 2.0, linestyle = :dash)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f8)","category":"page"},{"location":"quick_start/#Fossilized-Birth-Death-Diffusion-(FBDD):","page":"Quick start","title":"Fossilized Birth-Death Diffusion (FBDD):","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Tapestree\n\ntree = read_newick(\"<tree file directory in newick format>\", true)\n\nr, tv = insane_gbmfbd(tree,\n                      niter = 100_000,\n                      nthin = 1_000,\n                      ofile = \"<out files directory>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"note: Note\nFor the following I used here the 6 tip fossil tree tree_6.tre in the data directory of Tapestree.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"info: Info\nsTo have piece-wise constant preservation rates and add additional fossil occurrences, use the same arguments introduced just above in Constant fossilized birth-death process (CFBD).","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"We can plot the average speciation and extinction, after removing unsampled (DA) lineages and estimating the average using","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"tv0 = remove_unsampled(tv)\ntm  = imean(tv0)\np0 = plot(tm, birth)\np1 = plot(tm, death)\nplot(p0, p1, linewidth = 3.0)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f9)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"As with other birth-death diffusion models, we can plot the cross-lineage average speciation rate and extinction rates","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"p0 = plot(birth, 0.1, tv)\np1 = plot(death, 0.1, tv)\nplot(p0, p1)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f13)","category":"page"},{"location":"quick_start/#Diffused-Brownian-motion-(DBM)-model","page":"Quick start","title":"Diffused Brownian motion (DBM) model","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Tapestree, DelimitedFiles\n\ntree = read_newick(\"<tree file directory in newick format>\", true)\ntdat = readdlm(\"<trait file>\")\nxavg = Dict{String, Float64}(tdat[i,1] => tdat[i,2] for i in 1:size(tdat,1))\n\nr, tv = insane_dbm(tree, \n                   xavg,\n                   niter = 100_000,\n                   nthin = 1_000,\n                   ofile = \"<out files directory>\")","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"info: Info\nHere the <trait file> would be a simple .txt file with species names in the first column and continuous trait values in the second. For this example I used the tree_6.tre tree and trait data in trait.txt in the data directory of Tapestree.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"We can plot one random posterior trait history on the tree","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(rand(tv), xv, linewidth = 3.0)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f10)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Or we can plot the phenogram using","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"plot(xv, rand(tv), linewidth = 3.0)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f11)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"We can estimate the average posterior for the traits and rates","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"tm = imean(tv)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"and plot the average paths for trait and rate evolution","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"p0 = plot(xv, tm, linewidth = 3.0)\np1 = plot(lσ2, tm, linewidth = 3.0)\nplot(p0, p1)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"(Image: f12)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"To add trait uncertainty around the average values (assumed to be Normally distributed), one needs another Dictionary, just as with xavg above, but having each species point to the standard deviation to set the argument xs. For instance, if we have another simple .txt file with species names in the first column and standard deviations in the second:","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"tvar = readdlm(\"<trait file>\")\nxstd = Dict{String, Float64}(tdat[i,1] => tdat[i,2] for i in 1:size(tdat,1))\n\nr, tv = insane_dbm(tree, \n                   xavg,\n                   xs    = xstd,\n                   niter = 100_000,\n                   nthin = 1_000,\n                   ofile = \"<out files directory>\")","category":"page"},{"location":"quick_start/#ESSE-and-TRIBE","page":"Quick start","title":"ESSE & TRIBE","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"For ESSE and TRIBE go directly to the manual ESSE * TRIBE.","category":"page"},{"location":"man/insane/cbd/#Constant-pure-birth-(Yule)-process-(CPB)","page":"Constant birth-death","title":"Constant pure-birth (Yule) process (CPB)","text":"","category":"section"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"The simplest diversification model assumes no extinction (mu = 0) and a constant speciation rate lambda, also known as, the pure-birth or Yule model.","category":"page"},{"location":"man/insane/cbd/#Simulations","page":"Constant birth-death","title":"Simulations","text":"","category":"section"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"To simulate a pure-birth tree one can use sim_cpb. For instance, for a period of 10 time units and a speciation rate of lambda = 05:","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"tr = sim_cpb(10.0, 0.5)","category":"page"},{"location":"man/insane/cbd/#Inference","page":"Constant birth-death","title":"Inference","text":"","category":"section"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"To perform inference on a tree (of type sT_label), we can use the insane_cpb function (cpb = constant pure-birth).","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"r, tv = insane_cpb(tree,\n                   nburn  = 500,\n                   niter  = 1_000,\n                   nthin  = 2,\n                   nflush = nthin,\n                   ofile  = \"<directory>\")","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"note: Note\nthat For this specific CPB model, where the sampling fraction, rho, is 1, there are no unobserved components since we assume no extinction and that all species have been sampled. In this case, all the trees in the tree vector will be exactly the same.","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"In the following example, we now specify a global sampling fraction of 0.8.","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"r, tv = insane_cpb(tree,\n                   nburn  = 500,\n                   niter  = 1_000,\n                   nthin  = 2,\n                   nflush = nthin,\n                   ofile  = \"<directory>\",\n                   tρ     = Dict(\"\" => 0.8))","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"This time, the DA trees are different from one another since they have data augmented lineages that represent that proportion of species not included in the tree. The position change from tree to tree because we are integrating over their unknown placement. You can check this by plotting the trees (check Insane plots). For instance, to plot the first tree in the vector:","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"plot(tv[1])","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"note: Note\nInsane uses Gibbs sampling across most parameter updates in INSANE. So, the prior for speciation in the CPB is a Gamma prior, and its parameters can be specified with argument λ_prior, The default is λ_prior = (1.0, 1.0).","category":"page"},{"location":"man/insane/cbd/#Constant-birth-death-process-(CBD)","page":"Constant birth-death","title":"Constant birth-death process (CBD)","text":"","category":"section"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"We now consider that species have an instantaneous constant rate of extinction, mu, besides the constant rate of speciation lambda.","category":"page"},{"location":"man/insane/cbd/#Simulations-2","page":"Constant birth-death","title":"Simulations","text":"","category":"section"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"To simulate under the CBD model, say, for a period of 10, with speciation rate of 05, and extinction rate of 03, a one can use","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"tr = sim_cbd(10.0, 0.5, 0.3)","category":"page"},{"location":"man/insane/cbd/#Inference-2","page":"Constant birth-death","title":"Inference","text":"","category":"section"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"To perform inference on the CBD model, we can use","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"r, tv = insane_cbd(tree,\n                   nburn    = 1_000,\n                   niter    = 100_000,\n                   nthin    = 100, \n                   ofile    = \"<out file directory>\",\n                   λ_prior  = (1.0, 1.0),\n                   μ_prior  = (1.0, 1.0),\n                   survival = true,\n                   tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"where we now have a Gamma prior for the extinction mu, and we can also specify if we want to condition on survival of the process with survival.","category":"page"},{"location":"man/insane/cbd/","page":"Constant birth-death","title":"Constant birth-death","text":"Full documentation","category":"page"},{"location":"man/insane/cbd/#Tapestree.INSANE.sim_cpb","page":"Constant birth-death","title":"Tapestree.INSANE.sim_cpb","text":"sim_cpb(t::Float64, λ::Float64)\n\nSimulate a constant pure-birth iTree of height t with speciation rate λ.\n\n\n\n\n\nsim_cpb(t::Float64, λ::Float64, na::Int64)\n\nSimulate a constant pure-birth iTree of height t with speciation rate λ.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/cbd/#Tapestree.INSANE.sim_cbd","page":"Constant birth-death","title":"Tapestree.INSANE.sim_cbd","text":"sim_cbd(t::Float64, λ::Float64, μ::Float64)\n\nSimulate a constant birth-death iTree of height t with speciation rate λ and extinction rate μ.\n\n\n\n\n\nsim_cbd(t ::Float64,\n        λ ::Float64,\n        μ ::Float64,\n        na::Int64)\n\nSimulate a constant birth-death iTree of height t with speciation rate λ and extinction rate μ.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/cbd/#Tapestree.INSANE.insane_cpb","page":"Constant birth-death","title":"Tapestree.INSANE.insane_cpb","text":"insane_cpb(tree    ::sT_label;\n           λ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n           niter   ::Int64                 = 1_000,\n           nthin   ::Int64                 = 10,\n           nburn   ::Int64                 = 200,\n           nflush  ::Int64                 = nthin,\n           ofile   ::String                = string(homedir(), \"/cpb\"),\n           λi      ::Float64               = NaN,\n           pupdp   ::NTuple{2,Float64}     = (0.2, 0.2),\n           prints  ::Int64                 = 5,\n           tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for constant pure-birth.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/cbd/#Tapestree.INSANE.insane_cbd","page":"Constant birth-death","title":"Tapestree.INSANE.insane_cbd","text":"insane_cbd(tree    ::sT_label;\n           λ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n           μ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n           niter   ::Int64                 = 1_000,\n           nthin   ::Int64                 = 10,\n           nburn   ::Int64                 = 200,\n           nflush  ::Int64                 = nthin,\n           ofile   ::String                = string(homedir(), \"/cbd\"),\n           ϵi      ::Float64               = 0.4,\n           λi      ::Float64               = NaN,\n           μi      ::Float64               = NaN,\n           pupdp   ::NTuple{3,Float64}     = (0.2,0.2,0.2),\n           prints  ::Int64                 = 5,\n           survival::Bool                  = true,\n           mxthf   ::Float64               = Inf,\n           tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for constant birth-death.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/dbm/#Diffused-Brownian-motion-process-(DBM)","page":"Diffused Brownian motion","title":"Diffused Brownian motion process (DBM)","text":"","category":"section"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"This is a model of trait evolution where an univariate trait x(t) evolves under a diffused Brownian motion with an underlying evolutionary rate sigma^2(t) that is also itself evolving separately according to Geometric Brownian motion:","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"dx(t) = alpha_x dt + sigma(t) d W(t) \nd(textln(sigma^2(t)) = alpha_sigma dt + gamma d W(t)","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"where alpha_x is the trait drift (general trait tendency to increase or decrease), alpha_sigma is the drift in evolutionary rates, and gamma represents the heterogeneity in evolutionary rates.","category":"page"},{"location":"man/insane/dbm/#Simulations","page":"Diffused Brownian motion","title":"Simulations","text":"","category":"section"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"In the DBM, we are not modeling the realization of the tree, but rather a process that evolved along the tree. Thus, to simulate, we need a tree to be used as template so that we can simulate on top. So if we have a tree object of type sT_label or sTf_label, we can simulate a trait with a starting trait value of x0 (x(t = 0)), with drift αx (alpha_x), undergoing a starting rate of σ20 (sigma^2(t = 0)) with drift ασ (alpha_sigma), with a maximal discretization time step of δt:","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"sim_dbm(tree, x0 = 0.0, αx = 0.0, σ20 = 0.1, ασ = 0.0, γ = 0.1, δt = 1e-3)","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"which returns a tree of type sTxs, holding the simulation.","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"It might also be useful to return a Dictionary with the final trait values at each sampled species. For this, use the same function, in the same argument order but not using named (keyword) arguments. For instance, the same simulation above, but returning both a sTxs tree named tr and a dictionary of species values named xd:","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"tr, xd = sim_dbm(tree, 0.0, 0.0, 0.1, 0.0, 0.1, 1e-3)","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"We can plot the resulting tree using Tapestree's plot recipes (Insane plots). For example to plot the trait evolution colored by the logarithmic rates:","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"plot(xv, tr, zf = lσ2)","category":"page"},{"location":"man/insane/dbm/#Inference","page":"Diffused Brownian motion","title":"Inference","text":"","category":"section"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"For a given sT_label or sTf_label type tree object and a Dictionary xavg with a String key pointing to a Float64 number (i.e., Dict{String, Float64}), where matching tip labels point to the trait value. If species labels are not included in the dictionary, the trait value is assumed missing. ","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"r, td = insane_dbm(tree, \n                   xavg,\n                   γ_prior  = (0.05, 0.05),\n                   αx_prior = (0.0, 10.0),\n                   ασ_prior = (0.0, 10.0),\n                   nburn    = 10_000,\n                   niter    = 100_000,\n                   nthin    = 1_000,\n                   nflush   = 1_000,\n                   ofile    = \"<...directory...>\",\n                   δt       = 1e-3)","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"Finally, error or uncertainty around trait values can be included (assuming Normal variance) by setting another Dictionary, called say xsv, (also Dict{String, Float64}), where tip values point to the variance around trait values. Again, if tip labels are not included in this dictionary, it is assumed that there is no error around tip values. Then you specify this dictionary on the argument xs:","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"r, td = insane_dbm(tree, \n                   xavg, \n                   xs       = xsv,\n                   γ_prior  = (0.05, 0.05),\n                   αx_prior = (0.0, 10.0),\n                   ασ_prior = (0.0, 10.0),\n                   nburn    = 10_000,\n                   niter    = 100_000,\n                   nthin    = 1_000,\n                   nflush   = 1_000,\n                   ofile    = \"<...directory...>\",\n                   δt       = 1e-3)","category":"page"},{"location":"man/insane/dbm/","page":"Diffused Brownian motion","title":"Diffused Brownian motion","text":"Full documentation","category":"page"},{"location":"man/insane/dbm/#Tapestree.INSANE.sim_dbm","page":"Diffused Brownian motion","title":"Tapestree.INSANE.sim_dbm","text":"sim_dbm(tree::iTree; \n        x0  ::Float64 = 0.0,\n        αx  ::Float64 = 0.0,\n        σ20 ::Float64 = 0.1,\n        ασ  ::Float64 = 0.0,\n        γ   ::Float64 = 0.1,\n        δt  ::Float64 = 1e-3)\n\nSimulate a diffused Brownian motion given starting values.\n\n\n\n\n\nsim_dbm(tree::Tlabel, \n        x0  ::Float64,\n        αx  ::Float64,\n        σ20 ::Float64,\n        ασ  ::Float64,\n        γ   ::Float64,\n        δt  ::Float64)\n\nSimulate a diffused Brownian motion given starting values.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/dbm/#Tapestree.INSANE.insane_dbm","page":"Diffused Brownian motion","title":"Tapestree.INSANE.insane_dbm","text":"insane_dbm(tree     ::Tlabel,\n           xa       ::Dict{String, Float64};\n           xs       ::Dict{String, Float64} = Dict{String,Float64}(),\n           αx_prior ::NTuple{2,Float64} = (0.0, 10.0),\n           ασ_prior ::NTuple{2,Float64} = (0.0, 10.0),\n           γ_prior  ::NTuple{2,Float64} = (0.05, 0.05),\n           niter    ::Int64             = 1_000,\n           nthin    ::Int64             = 10,\n           nburn    ::Int64             = 200,\n           nflush   ::Int64             = nthin,\n           ofile    ::String            = string(homedir(), \"/dbm\"),\n           αi       ::Float64           = 0.0,\n           γi       ::Float64           = 1e-3,\n           pupdp    ::NTuple{4,Float64} = (0.1, 0.1, 0.05, 0.9),\n           δt       ::Float64           = 1e-3,\n           stn      ::Float64           = 0.1,\n           mxthf    ::Float64           = Inf,\n           prints   ::Int64             = 5)\n\nRun diffused Brownian motion trait evolution model.\n\n\n\n\n\n","category":"function"},{"location":"man/esse/#ESSE","page":"ESSE","title":"ESSE","text":"","category":"section"},{"location":"man/esse/#Reference","page":"ESSE","title":"Reference","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Quintero, I., Landis, M. J., Jetz, W., & Morlon, H. (2022). The build-up of the present-day tropical diversity of tetrapods. Proceedings of the National Academy of Sciences, 2023. 120 (20) e2220672120. https://doi.org/10.1073/pnas.2220672120","category":"page"},{"location":"man/esse/#Example","page":"ESSE","title":"Example","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"In this example we run some random data for 50 species across 2 areas, where each area has a specific covariate that affects speciation and we also allow for 2 hidden states.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Open Julia and load the Tapestree package: ","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"using Tapestree","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify the path to the phylogenetic tree (in a format that ape::read.tree() can read):","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"tree_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"tree_50.tre\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify state data. Data should be a .txt file where each row is a species,  first the species name that matches the tree tip labels and each subsequent column specifying presence or absence in a given area with 0 or 1,  respecitvely. Open st2_data.txt in the data folder to see an example for 2 areas.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"states_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"st2_data.txt\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify covariate data y = f(x). Data should be a .txt file where the  first column is time x in backward fashion (the present is 0 and the  past is  0), and the subsequent columns are the respective time covariates for each area f(x). If there is only one covariate, the same is used across all areas, if not, the number of covariates should match the specific model.  More than one covariate per area is allowed, and in the case of covariates  affecting colonization rates, they should match the number of possible  colonization parameters between all areas. Open env_data_2.txt in the data folder to see an example for 2 covariates for 2 areas.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"envdata_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"env_data_2.txt\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify output MCMC file (homedir() is an alias to your home folder)","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"out_file = *(homedir(),\"...\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify the (optional) output file (homedir() is an alias to your home  folder) for the node marginal probabilities. ","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"out_states = *(homedir(),\"...\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Run the esse() (ESSE: Environmental and State dependent Speciation and  Extinction) model, with covariates affecting speciation rates:","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"esse(tree_file, out_file, 2, envdata_file = envdata_file, \n  states_file = states_file, out_states = out_states, cov_mod = (\"s\",))","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"If one would like to make the covariates affect other rates, such as dispersal, in addition to speciation rates, one would specify the following covariate model cov_mod = (\"s\",\"g\"). Note however that this has not been validated.  Moreover, covariate effect on extinction is non retrievable from extant-only phylogenetic trees.","category":"page"},{"location":"man/esse/#Parallel-MC3","page":"ESSE","title":"Parallel MC3","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"It is encouraged to use Metropolis coupled MCMC (MC3) for more robust  convergence (the posterior surfaced is highly peaked).","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Load the Distributed package, set the number of processors for Julia, and make Tapestree available to all (see the Distributed  package for more information). Below we add 3 processors.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"using Distributed\naddprocs(3)\n@everywhere using Tapestree","category":"page"},{"location":"man/esse/#Set-parameter-constraints","page":"ESSE","title":"Set parameter constraints","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"To constrain parameters to be equal to one another or to fix them to be 0,  it is necessary to create equalities between parameters and pass them as an  argument. In general parameters are specified as follows:    \"<parameter name>_<area>_<hidden state>\"","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Speciation is \"lambda\" (e.g. speciation rate for area A and hidden state 0: lambda_A_0)\nLocal extinction is \"loss\" (e.g. local extinction rate for area B and hidden state 1: loss_B_1)\ncolonization is \"gain\" (e.g. gain rate from A -> B and hidden state 1: gain_AB_1)\nthe effect of the covariate is \"beta_<effect parameter name>\" (e.g. effect of first covariate on speciation in area A and hidden state 0: beta_lambda_1_A_0 - here the 1 after the lambda is because is the first covariate)\ntransition between hidden states is \"q\" (e.g. transition rate from hidden state 0 -> 1 and hidden state 1: q_01). ","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"You have to make sure that the given constraints apply to the specification of  model. In the following example, we constraint local and global extinction rates to be the same across 2 areas and 2 hidden states , and constrain the hidden states transition rates.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"cpar = (\"q_01 = q_10\",\n        \"loss_A_0 = mu_A_0\",\n        \"loss_B_0 = mu_B_0\",\n        \"loss_A_1 = mu_A_1\",\n        \"loss_B_1 = mu_B_1\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"We now run esse, using MC3 with Metropolis-Hastings MCMC (here using 3 parallel chains).","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"esse(tree_file, out_file, 2,\n     envdata_file = envdata_file,\n     states_file  = states_file, \n     out_states   = out_states,\n     constraints  = cpar,\n     cov_mod      = (\"s\",),\n     ncch         = 3,\n     parallel     = true,\n     niter        = 5_000,\n     nthin        = 100,\n     dt           = 0.8,\n     nburn        = 1_000, \n     mc           = \"mh\",\n     node_ps      = (true, 100))","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"For optional (keyword) arguments, see below","category":"page"},{"location":"man/esse/#Function-Documentation","page":"ESSE","title":"Function Documentation","text":"","category":"section"},{"location":"man/esse/#Tapestree.ESSE.esse","page":"ESSE","title":"Tapestree.ESSE.esse","text":"esse(tree_file   ::String,\n     out_file    ::String,\n     h           ::Int64;\n     states_file ::String            = \"NaN\",\n     envdata_file::String            = \"NaN\",\n     cov_mod     ::NTuple{M,String}  = (\"\",),\n     node_ps     ::Tuple{Bool,Int64} = (true, 10),\n     out_states  ::String            = \"\",\n     constraints ::NTuple{N,String}  = (\" \",),\n     mvpars      ::NTuple{O,String}  = (\" \",),\n     niter       ::Int64             = 10_000,\n     nthin       ::Int64             = 10,\n     nburn       ::Int64             = 200,\n     tune_int    ::Int64             = 100,\n     nswap       ::Int64             = 10,\n     ncch        ::Int64             = 1,\n     parallel    ::Bool              = ncch > 1,\n     dt           ::Float64          = 0.2,\n     ntakew      ::Int64             = 100,\n     winit       ::Float64           = 2.0,\n     scale_y     ::NTuple{2,Bool}    = (true, false),\n     algorithm   ::String            = \"pruning\",\n     mc          ::String            = \"slice\",\n     λpriors     ::Float64           = .1,\n     μpriors     ::Float64           = .1,\n     gpriors     ::Float64           = .1,\n     lpriors     ::Float64           = .1,\n     qpriors     ::Float64           = .1,\n     βpriors     ::NTuple{2,Float64} = (0.0, 10.0),\n     hpriors     ::Float64           = .1,\n     optimal_w   ::Float64           = 0.8,\n     tni         ::Float64           = 1.0,\n     obj_ar      ::Float64           = 0.6,\n     screen_print::Int64             = 5,\n     Eδt         ::Float64           = 1e-3,\n     ti          ::Float64           = 0.0,\n     ρ           ::Array{Float64,1}  = [1.0]) where {M,N,O}\n\nRun geographic esse. See tutorial for how these files should be specified.\n\nArguments\n\ntree_file::String: full path to tree file.\nout_file::String: full path to write MCMC output.\nh::Int64: number of hidden states.\nstates_file ::String = \"NaN\": full path to states file. If \"NaN\", no \n\nobserved states are used (only hidden states).\n\nenvdata_file::String = \"NaN\": full path to covariates file. If \"NaN\", no \n\ncovariates are used (i.e., constant rates).\n\ncov_mod::NTuple{M,String} = (\"\",): specifies which rates are affected by \n\ncovariates: s for speciation, e for extinction, and g for colonization. More than 1 is possible.\n\nnode_ps::Tuple{Bool,Int64} = (true, 10): first index specifies if posterior\n\nmarginal probabilities for nodes should be computed, second index the number of iterations to be computed. \n\nout_states::String = \"\": full path to write node probabilities output.\nconstraints::NTuple{N,String} = (\" \",): constraints for the model \n\nparameters.\n\nmvpars::NTuple{O,String} = (\" \",): which parameters should be multivariate \n\nwhen using slice sampling for better convergence.\n\nniter::Int64 = 10_000: number of iterations.\nnthin::Int64 = 10: frequency at which to record MCMC state.\nnburn::Int64 = 200: number of iterations to discard as burn-in.\ntune_int::Int64 = 100: number of iterations during nburn to tune proposal\n\nwindow for MH.\n\nnswap::Int64 = 10: every iteration to try to swap chain likelihoods in MC3.\nncch::Int64 = 1: number of chains.\nparallel::Bool = false: if parallel run.\ndt::Float64 = 0.2: temperature for MC3.\nntakew::Int64 = 100: number of iterations from nburn to tune the window\n\nfor slice sampling.\n\nwinit::Float64 = 2.0: initial window for slice sampling.\nscale_y::NTuple{2,Bool} = (true, false): first index if scale covariates y\n\nto [0,1], second, if scale covariates y all together between [0,1].\n\nalgorithm::String = \"pruning\": likelihood algorithm between pruning \n\n(recommended) or flow.\n\nmc::String = \"slice\": which sampling slice (slice-sampling) or \n\nmh (metropolis-hasting).\n\nλpriors::Float64 = 0.1: rate of Exponential prior for speciation.\nμpriors::Float64 = 0.1: rate of Exponential prior for global extinction.\ngpriors::Float64 = 0.1: rate of Exponential prior for colonization.\nlpriors::Float64 = 0.1: rate of Exponential prior for local extinction.\nqpriors::Float64 = 0.1: rate of Exponential prior for hidden state \n\ntransitions.\n\nβpriors::NTuple{2,Float64} = (0.0, 10.0): mean and variance of Normal \n\nprior for effect of covariates.\n\nhpriors::Float64 = 0.1: rate of Exponential prior for differences between\n\nhidden states.\n\noptimal_w::Float64 = 0.8: optimal window.\ntni::Float64 = 1.0: initial tuning for rates.\nobj_ar::Float64 = 0.23: objective acceptance rate.\nscreen_print::Int64 = 5: seconds to wait to update screen log.\nEδt::Float64 = 1e-3: for flow algorithm.\nti::Float64 = 0.0: for flow algorithm.\nρ::Array{Float64,1} = [1.0]: sampling fraction for each state (each area and\n\nwidespread).\n\nReturned values\n\nArray of the mcmc parameters.\n\n\n\n\n\nesse(tv          ::Dict{Int64,Array{Float64,1}},\n     ed          ::Array{Int64,2}, \n     el          ::Array{Float64,1}, \n     x           ::Array{Float64,1},\n     y           ::Array{Float64,L}, \n     cov_mod     ::NTuple{M,String},\n     out_file    ::String,\n     h           ::Int64;\n     constraints ::NTuple{N,String}  = (\" \",),\n     mvpars      ::NTuple{O,String}  = (\"lambda = beta\",),\n     niter       ::Int64             = 10_000,\n     nthin       ::Int64             = 10,\n     nburn       ::Int64             = 200,\n     ncch        ::Int64             = 1,\n     ntakew      ::Int64             = 100,\n     winit       ::Float64             = 2.0,\n     scale_y     ::NTuple{2,Bool}    = (true, false),\n     algorithm   ::String            = \"pruning\",\n     λpriors     ::Float64           = .1,\n     μpriors     ::Float64           = .1,\n     gpriors     ::Float64           = .1,\n     lpriors     ::Float64           = .1,\n     qpriors     ::Float64           = .1,\n     βpriors     ::NTuple{2,Float64} = (0.0, 10.0),\n     hpriors     ::Float64           = .1,\n     optimal_w   ::Float64           = 0.8,\n     screen_print::Int64             = 5,\n     Eδt         ::Float64           = 1e-3,\n     ti          ::Float64           = 0.0,\n     ρ           ::Array{Float64,1}  = [1.0]) where {L,M,N,O}\n\nWrapper for running a esse model from simulations.\n\n\n\n\n\n","category":"function"},{"location":"man/esse/#Tapestree.ESSE.simulate_sse","page":"ESSE","title":"Tapestree.ESSE.simulate_sse","text":"simulate_sse(λ          ::Array{Float64,1},\n             μ          ::Array{Float64,1},\n             l          ::Array{Float64,1},\n             g          ::Array{Float64,1},\n             q          ::Array{Float64,1},\n             t          ::Float64;\n             δt         ::Float64 = 1e-4,\n             ast        ::Int64   = 0,\n             nspp_max   ::Int64   = 100_000,\n             retry_ext  ::Bool    = true,\n             rejectel0  ::Bool    = true,\n             verbose    ::Bool    = true,\n             rm_ext     ::Bool    = true,\n             states_only::Bool    = false, \n             start      ::Symbol  = :crown)\n\nSimulate tree according to the geographic esse model. The number of areas  and hidden states is inferred from the parameter vectors, but they must be  consistent between them and with the covariates. See tutorial for an example.\n\nArguments\n\nλ::Array{Float64,1}: rates for within-area and between-area speciation.\nμ::Array{Float64,1}: per-area extinction rates when it leads to global \n\nextinction.\n\nl::Array{Float64,1}: per-area extinction rates when it leads to local \n\nextinction.\n\ng::Array{Float64,1}: colonization rates between areas. \nq::Array{Float64,1}: transition rates between hidden states.\nt::Float64: simulation time.\nδt::Float64 = 1e-4: time step to perform simulations. Smaller more precise \n\nbut more computationally expensive.\n\nast::Int64 = 0: initial state. 0 specifies random sampling based on the \n\ninput parameters.\n\nnspp_max::Int64 = 100_000: maximum number of species allowed to stop \n\nsimulation.\n\nretry_ext::Bool = true: automatically restart simulation if simulation goes\n\nextinct.\n\nrejectel0::Bool = true: reject simulations where there are edges of 0 \n\nlength.\n\nverbose::Bool = true: print messages.\nrm_ext::Bool = true: remove extinct taxa from output.\nstates_only::Bool = false: if only return tip states (faster).\nstart::Symbol  = :crown: if crown, starts after a speciation event with \n\ntwo lineages, if stem, starts with one lineage.\n\nReturned values\n\nDictionary with tip number and corresponding state.\nArray with parent -> daughter edges.\nArray with edge lengths.\nNumber of maximum species.\n\n\n\n\n\nsimulate_sse(λ          ::Array{Float64,1},\n             μ          ::Array{Float64,1},\n             l          ::Array{Float64,1},\n             g          ::Array{Float64,1},\n             q          ::Array{Float64,1},\n             β          ::Array{Float64,1},\n             t          ::Float64,\n             x          ::Array{Float64,1},\n             y          ::Array{Float64,N},\n             cov_mod    ::Tuple{Vararg{String}};\n             δt         ::Float64 = 1e-4,\n             ast        ::Int64   = 0,\n             nspp_max   ::Int64   = 100_000,\n             retry_ext  ::Bool    = true,\n             rejectel0  ::Bool    = true,\n             verbose    ::Bool    = true,\n             rm_ext     ::Bool    = true,\n             states_only::Bool    = false,\n             start      ::Symbol  = :crown) where {N}\n\nSimulate tree according to the geographic sse model. The number of areas  and hidden states is inferred from the parameter vectors, but they must be  consistent between them and with the covariates. See tutorial for an example.\n\nArguments\n\nλ::Array{Float64,1}: rates for within-area and between-area speciation.\nμ::Array{Float64,1}: per-area extinction rates when it leads to global \n\nextinction.\n\nl::Array{Float64,1}: per-area extinction rates when it leads to local \n\nextinction.\n\ng::Array{Float64,1}: colonization rates between areas. \nq::Array{Float64,1}: transition rates between hidden states.\nβ::Array{Float64,1}: per-area effect of covariates.\nt::Float64: simulation time.\nx::Array{Float64,1}: times where the covariate y is sampled.\ny::Array{Float64,N}: value of covariates, i.e., f(x). Can be multivariate.\ncov_mod::Tuple{Vararg{String}}: specifies which rates are affected by \n\ncovariates: s for speciation, e for extinction, and g for colonization. More than 1 is possible. \n\nδt::Float64 = 1e-4: time step to perform simulations. Smaller more precise \n\nbut more computationally expensive.\n\nast::Int64 = 0: initial state. 0 specifies random sampling based on the \n\ninput parameters.\n\nnspp_max::Int64 = 100_000: maximum number of species allowed to stop \n\nsimulation.\n\nretry_ext::Bool = true: automatically restart simulation if simulation goes\n\nextinct.\n\nrejectel0::Bool = true: reject simulations where there are edges of 0 \n\nlength.\n\nverbose::Bool = true: print messages.\nrm_ext::Bool = true: remove extinct taxa from output.\nstates_only::Bool = false: if only return tip states (faster).\nstart::Symbol  = :crown: if crown, starts after a speciation event with \n\ntwo lineages, if stem, starts with one lineage.\n\nReturned values\n\nDictionary with tip number and corresponding state.\nArray with parent -> daughter edges.\nArray with edge lengths.\nNumber of maximum species.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Birth-death-diffusion-(BDD)-processes","page":"Birth-death diffusion","title":"Birth-death diffusion (BDD) processes","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"These models all assume that the per-lineage instantaneous speciation rates lambda(t) follow a Geometric Brownian motion (GBM), such that","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"d(textln(lambda(t)) = alpha dt + sigma_lambda d W(t)","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"where alpha is the drift, sigma_lambda is the diffusion for speciation, and W(t) is the Wiener process (i.e., standard Brownian motion), and holding different assumptions on extinction.","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"The likelihood is approximated using the Euler method to solve Stochastic Differential Equations, and require to set a minimum time step for the discretization of the augmented diffusion paths. In INSANE δt (by default 10^-3) sets the time step to perform the Euler approximation, and denotes the proportion with respect to the tree height (the duration of the tree), so the time step will be δt = th times 10^-3, where th is the tree height.","category":"page"},{"location":"man/insane/bdd/#Pure-birth-diffusion-(\\mu(t)-0)","page":"Birth-death diffusion","title":"Pure birth diffusion (mu(t) = 0)","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"In the simplest BDD model, the pure-birth diffusion, we assume there is no extinction, that is mu(t) = 0.","category":"page"},{"location":"man/insane/bdd/#Simulations","page":"Birth-death diffusion","title":"Simulations","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"For all the BDD models, we have the possibility to simulate conditioned on total simulation time or the number of species.","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"To simulate conditioned on some number of species, say, 20, with starting speciation rate of lambda_0 = 10, drift of alpha = 0 and diffusion of sigma_lambda = 01, we can use:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":" sim_gbmpb(20, λ0 = 1.0, α = 0.0, σλ = 0.1)","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Similarly, to simulate conditioned on time, say, 10 time units, with the same parameters, we can use:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":" sim_gbmpb(10.0, λ0 = 1.0, α = 0.0, σλ = 0.1)","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Other options are available, such as δt which controls the time step of the simulation, which uses the Euler approximation. Similarly, init can be :crown or :stem to simulate starting with 1 or 2 lineages. ","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"note: Note\nThe simulations conditioned on time must input a Float64 as first (and mandatory) argument while those conditioned on number of species must rater input a Int64.","category":"page"},{"location":"man/insane/bdd/#Inference","page":"Birth-death diffusion","title":"Inference","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"To perform inference under this model we can use:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"r, tv = insane_gbmpb(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.05, 0.05),\n                     tρ    = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Here, the prior for the drift α_prior is a Normal distribution, with the first element representing the mean and the second the standard deviation, and the prior for the diffusion in speciation rates. σλ_prior, is an Inverse Gamma. ","category":"page"},{"location":"man/insane/bdd/#Birth-death-diffusion-process-with-constant-extinction-(\\mu(t)-\\mu)","page":"Birth-death diffusion","title":"Birth-death diffusion process with constant extinction (mu(t) = mu)","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Here we assume that there is extinction, but that is constant across lineages and time.","category":"page"},{"location":"man/insane/bdd/#Simulations-2","page":"Birth-death diffusion","title":"Simulations","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"As with the pure-birth diffusion, we can simulate conditioned on reaching some number of lineages or some time. Now, however, we need to specify the extinction rate as well, for instance to generate a tree with 20 species and some parameter values:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":" sim_gbmce(20, λ0 = 1.0, α = 0.0, σλ = 0.1, μ = 0.7)","category":"page"},{"location":"man/insane/bdd/#Inference-2","page":"Birth-death diffusion","title":"Inference","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"To perform inference we can use","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"r, tv = insane_gbmce(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.05, 0.05),\n                     μ_prior  = (1.0, 1.0),\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"where we now specify the Gamma prior μ_prior for the extinction.","category":"page"},{"location":"man/insane/bdd/#Birth-death-diffusion-process-with-constant-turnover-(\\mu(t)-\\epsilon-\\lambda(t))","page":"Birth-death diffusion","title":"Birth-death diffusion process with constant turnover (mu(t) = epsilon lambda(t))","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"One can also assume that turnover, epsilon, that is, the ration of extinction over speciation (i.e., fracmulambda), is constant.","category":"page"},{"location":"man/insane/bdd/#Simulations-3","page":"Birth-death diffusion","title":"Simulations","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"As with the other BDD models, we can simulate both conditioned on the number of species or in time. For instance, here we condition on time with a turnover rate of 04.","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":" sim_gbmct(10.0, λ0 = 1.0, α = 0.0, σλ = 0.1, ϵ = 0.4)","category":"page"},{"location":"man/insane/bdd/#Inference-3","page":"Birth-death diffusion","title":"Inference","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Performing inference can then be done using:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"r, tv = insane_gbmct(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.05, 0.05),\n                     ϵ_prior  = (0.0, 100.0),\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"where we now specify a Uniform prior ϵ_prior for the turnover. Also, Tapestree resorts to simple MH updates for epsilon, so an increased burnin is recommended. ","category":"page"},{"location":"man/insane/bdd/#Birth-death-diffusion-process","page":"Birth-death diffusion","title":"Birth-death diffusion process","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Finally, we arrive at the most complex model, where extinction also follows a GBM, that is,","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"d(textln(mu(t)) = sigma_mu d W(t)","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"where sigma_mu is the diffusion for extinction.","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"note: Note\nThis is unidentifiable, unless we specify strong priors on the extinction diffusion coefficient sigma_mu, and still do not do well in recovering simulated values, at least for small trees.","category":"page"},{"location":"man/insane/bdd/#Simulations-4","page":"Birth-death diffusion","title":"Simulations","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Again, one can specify a time or a number of lineages to simulate under the BDD. For example, for 50 species","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":" sim_gbmbd(50, λ0 = 1.0, μ0 = 1.0, α = 0.0, σλ = 0.1, σμ = 0.1)","category":"page"},{"location":"man/insane/bdd/#Inference-4","page":"Birth-death diffusion","title":"Inference","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"One can perform inference using:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"r, tv = insane_gbmbd(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     λ0_prior = (0.05, 148.41),\n                     μ0_prior = (0.05, 148.41),\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.05, 0.05),\n                     σμ_prior = (3.0, 0.1),\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"where we have log-normal priors on the initial (root) values for lambda_0 and mu_0, and Inverse Gamma prior for sigma. Usually, an informative prior such as σμ_prior = (3.0, 0.1) or more is needed.","category":"page"},{"location":"man/insane/bdd/#Birth-death-diffusion-process-with-informed-extinction","page":"Birth-death diffusion","title":"Birth-death diffusion process with informed extinction","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"One can also define a branch-specific fixed extinction function and make inference on the GBM speciation. For example, in Quintero et al. (2024) Science, we estimated extinction rates based on fossil occurrences and then used this as input.","category":"page"},{"location":"man/insane/bdd/#Inference-5","page":"Birth-death diffusion","title":"Inference","text":"","category":"section"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"To make inference under this model, we need two vectors where each element links to a given branch in the reconstructed tree, in the same order as the phylogenetic tree. Each element of these vectors are themselves a vector of type Float64, and correspond to the time at which extinction is recovered in time backward order (e.g., [1.1, 1.0, ..., 0.1, 0.08, 0.0]) and to the extinction at those times. INSANE uses a linear approximation function between the input sampled points.","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"To make inference under this model, we now input these vectors. Lets call them time_vector (of type Vector{Vector{Float64}}) and extinction_vector (also of type Vector{Vector{Float64}}), then:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"r, tv = insane_gbmbd(tree,\n                     time_vector,\n                     extinction_vector,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"The only thing one has to make sure is that the order of time_vector and extinction_vector correspond to the order of the branches in tree, which can be a bit involved. However, this can be achieved by understanding that the trees are recursive and are ordered either by left or right branch, and using some of the tree utility functions. ","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"For example, one can use the subclade function, to extract a subclade given a set of tip labels. One can also use the make_idf function, which splits the tree into a vector of branches in the same order that INSANE will process the tree. This way one can see the ordering of branches, and then order the time_vector and the extinction_vector in the same order.","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"If only one extinction function is used for all the tree, then one has to only create a vector of the time and extinction vector of equal size as the number of branches.","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"To estimate the number of branches in your empirical tree (saved in <...tree directory...>), we can do:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"# read tree\ntre = read_newick(\"<...tree directory...>\")\n\n## make extinction function vectors for each branch\n# set a dummy smapling fraction (you can set the real one afterwards! - this is just to estimate the number of branches)\ntρ  = Dict(li => 1.0 for li in tiplabels(tre))\nidf = make_idf(tre, tρ, Inf)\n\n# number of branches\nnb = length(idf)","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"If we have a global curve with extinction [0.06, 0.02, 0.05] at times [0.5, 0.3, 0.1], then we would have to create the following input objects for time_vector and extinction_vector:","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"extinction_vector = fill([0.06, 0.02, 0.05], nb)\ntime_vector = fill([0.5, 0.3, 0.1], nb)","category":"page"},{"location":"man/insane/bdd/","page":"Birth-death diffusion","title":"Birth-death diffusion","text":"Full documentation","category":"page"},{"location":"man/insane/bdd/#Tapestree.INSANE.sim_gbmpb","page":"Birth-death diffusion","title":"Tapestree.INSANE.sim_gbmpb","text":"sim_gbmpb(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          δt      ::Float64 = 1e-3,\n          init    ::Symbol  = :stem,\n          nstar   ::Int64   = n + 2,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true,\n          maxt    ::Float64 = δt*1e7)\n\nSimulate iTpb according to a pure-birth geometric Brownian motion.\n\n\n\n\n\nsim_gbmpb(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTpb according to a pure-birth geometric Brownian motion conditional in stopping at time t.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Tapestree.INSANE.sim_gbmce","page":"Birth-death diffusion","title":"Tapestree.INSANE.sim_gbmce","text":"sim_gbmce(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          μ       ::Float64 = 0.0,\n          δt      ::Float64 = 1e-3,\n          init    ::Symbol  = :stem,\n          nstar   ::Int64   = 2*n,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true,\n          maxt    ::Float64 = δt*1e7)\n\nSimulate iTce according to a geometric Brownian motion for birth rates and constant extinction.\n\n\n\n\n\nsim_gbmce(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          μ   ::Float64 = 0.2,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTce according to a geometric Brownian motion for birth rates and constant extinction.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Tapestree.INSANE.sim_gbmct","page":"Birth-death diffusion","title":"Tapestree.INSANE.sim_gbmct","text":"sim_gbmct(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          ϵ       ::Float64 = 0.0,\n          δt      ::Float64 = 1e-3,\n          init    ::Symbol  = :stem,\n          nstar   ::Int64   = 2*n,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true,\n          maxt    ::Float64 = δt*1e7)\n\nSimulate iTct according to a geometric Brownian motion for birth rates and constant turnover.\n\n\n\n\n\nsim_gbmct(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          ϵ   ::Float64 = 0.2,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTct according to a geometric Brownian motion for birth rates and constant turnover.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Tapestree.INSANE.sim_gbmbd","page":"Birth-death diffusion","title":"Tapestree.INSANE.sim_gbmbd","text":"sim_gbmbd(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          μ0      ::Float64 = 0.1,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          σμ      ::Float64 = 0.1,\n          init    ::Symbol  = :stem,\n          δt      ::Float64 = 1e-3,\n          nstar   ::Int64   = 2*n,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true)\n\nSimulate iTbd according to geometric Brownian motions for birth and death rates.\n\n\n\n\n\nsim_gbmbd(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          μ0  ::Float64 = 0.2,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          σμ  ::Float64 = 0.1,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTbd according to geometric Brownian motions for birth and death rates.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Tapestree.INSANE.insane_gbmpb","page":"Birth-death diffusion","title":"Tapestree.INSANE.insane_gbmpb","text":"insane_gbmpb(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 1.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ipb\"),\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.1,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.01, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             stn     ::Float64               = 0.5,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for pbd.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Tapestree.INSANE.insane_gbmce","page":"Birth-death diffusion","title":"Tapestree.INSANE.insane_gbmce","text":"insane_gbmce(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 10.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             μ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ice\"),\n             λi      ::Float64               = NaN,\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.01,\n             μi      ::Float64               = NaN,\n             ϵi      ::Float64               = 0.2,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.01, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = 0.1,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for gbm-ce.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Tapestree.INSANE.insane_gbmct","page":"Birth-death diffusion","title":"Tapestree.INSANE.insane_gbmct","text":"insane_gbmct(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 1.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             ϵ_prior ::NTuple{2,Float64}     = (0.0, 10.0),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ict\"),\n             tune_int::Int64                 = 100,\n             αi      ::Float64               = 0.0,\n             λi      ::Float64               = NaN,\n             σλi     ::Float64               = 0.01,\n             ϵi      ::Float64               = 0.2,\n             ϵtni    ::Float64               = 0.1,\n             obj_ar  ::Float64               = 0.234,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.01, 0.1, 0.2),\n             ntry    ::Int64                 = 2,\n             nlim    ::Int64                 = 500,\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = Inf,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for GBM birth-death.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/bdd/#Tapestree.INSANE.insane_gbmbd","page":"Birth-death diffusion","title":"Tapestree.INSANE.insane_gbmbd","text":"insane_gbmbd(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             μ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 10.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             σμ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ibd\"),\n             ϵi      ::Float64               = 0.2,\n             λi      ::Float64               = NaN,\n             μi      ::Float64               = NaN,\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.01,\n             σμi     ::Float64               = 0.01,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.0001, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = 0.1,\n             prints  ::Int64                 = 5,\n             stnλ    ::Float64               = 0.5,\n             stnμ    ::Float64               = 0.5,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for bdd.\n\n\n\n\n\ninsane_gbmbd(tree    ::sT_label,\n             tv      ::Vector{Vector{Float64}},\n             ev      ::Vector{Vector{Float64}};\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             μ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 0.5),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             σμ_prior::NTuple{2,Float64}     = (5.0, 0.5),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ibd_efx\"),\n             ϵi      ::Float64               = 0.2,\n             λi      ::Float64               = NaN,\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.01,\n             σμi     ::Float64               = 0.01,\n             pupdp   ::NTuple{4,Float64}     = (0.01, 0.01, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = Inf,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for gbm-bd with fixed extinction.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/contents/#INSANE","page":"Contents","title":"INSANE","text":"","category":"section"},{"location":"man/insane/contents/#Insane-Bayesian-data-augmentation","page":"Contents","title":"Insane Bayesian data augmentation","text":"","category":"section"},{"location":"man/insane/contents/","page":"Contents","title":"Contents","text":"INSANE uses Bayesian data augmentation (DA) to perform inference on a number of evolutionary models on phylogenetic trees. As such, performing inference will output posterior samples for the governing parameters as well as complete or data augmented trees, that is, trees that include probable configurations of unobserved variables such as the lineages that went extinct in the past or the underlying (latent) speciation rates. ","category":"page"},{"location":"man/insane/contents/#References","page":"Contents","title":"References","text":"","category":"section"},{"location":"man/insane/contents/","page":"Contents","title":"Contents","text":"Constant birth-death (CBD) and birth-death diffusions (BDD): Quintero, I., Lartillot, N., Morlon, H. (2024). Imbalanced speciation pulses sustain the radiation of mammals. Science, 384: 1007-1012. link","category":"page"},{"location":"man/insane/contents/","page":"Contents","title":"Contents","text":"Constant fossilized birth-death (CFBD) and fossilized birth-death diffusion (FBDD): Quintero, I., Andréoletti, J., Silvestro, D., & Morlon, H. (2025). \"The rise, decline and fall of clades\". BioRxiv  link","category":"page"},{"location":"man/insane/contents/","page":"Contents","title":"Contents","text":"Diffused Brownian motion (DBM): Quintero, I. (2025). The diffused evolutionary dynamics of morphological novelty. Proceedings of the National Academy of Sciences, U.S.A. 122 (18) e2425573122, link.","category":"page"},{"location":"man/insane/contents/#Insane-input-and-structures","page":"Contents","title":"Insane input and structures","text":"","category":"section"},{"location":"man/insane/contents/","page":"Contents","title":"Contents","text":"Pages = [\n  \"man/insane/io.md\"\n]\nDepth = 2","category":"page"},{"location":"man/insane/contents/#Insane-models","page":"Contents","title":"Insane models","text":"","category":"section"},{"location":"man/insane/contents/","page":"Contents","title":"Contents","text":"Pages = [\n  \"man/insane/cbd.md\",\n  \"man/insane/bdd.md\",\n  \"man/insane/cfbd.md\",\n  \"man/insane/fbdd.md\",\n  \"man/insane/dbm.md\",\n]\nDepth = 2","category":"page"},{"location":"man/insane/contents/#Insane-plots-and-utilities","page":"Contents","title":"Insane plots and utilities","text":"","category":"section"},{"location":"man/insane/contents/","page":"Contents","title":"Contents","text":"Pages = [\n  \"man/insane/processing.md\"\n  \"man/insane/iplots.md\"\n]\nDepth = 2","category":"page"},{"location":"man/tribe/#TRIBE","page":"TRIBE","title":"TRIBE","text":"","category":"section"},{"location":"man/tribe/#Reference","page":"TRIBE","title":"Reference","text":"","category":"section"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Quintero, I., & Landis, M. J. (2020). Interdependent phenotypic and biogeographic evolution driven by biotic interactions. Systematic biology, 69(4), 739-755. https://doi.org/10.1093/sysbio/syz082","category":"page"},{"location":"man/tribe/#Example","page":"TRIBE","title":"Example","text":"","category":"section"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Open Julia and load the Tapestree package: ","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"using Tapestree","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Specify the path to the phylogenetic tree (in a format that ape::read.tree() can read):","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"finches_tree_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"finches_rescaled.tre\")","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Specify data. Data should be a .txt file where each row is a species, first  the species name that matches the tree tip labels, second the phenotypic data  and then the species presence in each area (0 if absent and 1 if present).  Open finches_pca1.txt in the data folder to see an example.","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"finches_data_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"finches_pca1.txt\")","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Specify output file (homedir() is an alias to your home folder)","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"out_file = *(homedir(),\"...\")","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Run the tribe() (TRIBE: Trait and Range Interspecific Biogeographic Evolution) model:","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"tribe(finches_tree_file, finches_data_file, out_file)","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"For optional (keyword) arguments, see below","category":"page"},{"location":"man/tribe/#Function-Documentation","page":"TRIBE","title":"Function Documentation","text":"","category":"section"},{"location":"man/tribe/#Tapestree.TRIBE.tribe","page":"TRIBE","title":"Tapestree.TRIBE.tribe","text":"tribe(tree_file   ::String,\n      data_file   ::String,\n      out_file    ::String;\n      min_dt      ::Float64           = 0.01,\n      niter       ::Int64             = 50_000,\n      nburn       ::Int64             = 50_000,\n      nthin       ::Int64             = 500,\n      saveXY      ::Tuple{Bool,Int64} = (false, 1_000),\n      saveDM      ::Tuple{Bool,Int64} = (false, 1_000),\n      ωxprior     ::NTuple{2,Float64} = (0.,10.),\n      ω1prior     ::NTuple{2,Float64} = (0.,10.),\n      ω0prior     ::NTuple{2,Float64} = (0.,10.),\n      σ²prior     ::Float64           = 1e-1,\n      λprior      ::Float64           = 1e-1,\n      weight      ::NTuple{5,Float64} = (0.15,0.05,0.02,0.02,5e-3),\n      λ1i         ::Float64           = 1.0,\n      λ0i         ::Float64           = 0.5,\n      ωxi         ::Float64           = 0.0,\n      ω1i         ::Float64           = 0.0,\n      ω0i         ::Float64           = 0.0,\n      fix_ωx      ::Bool              = false,\n      fix_ω1      ::Bool              = false,\n      fix_ω0      ::Bool              = false,\n      delim       ::Char              = '\t',\n      eol         ::Char              = '\r',\n      screen_print::Int64             = 5)\n\nRun tribe model. \n\n...\n\nArguments\n\ntree_file::String: full path to tree file.\ndata_file::String: full path to data file.\nout_file::String: full path to write MCMC output.\nmin_dt::Float64 = 0.01: the percentage of tree height allowed for \n\ndiscretization (lower values are more precise but take longer).\n\nniter::Int64 = 50_000: the number of iterations.\nnburn::Int64 = 50_000: the number of iterations in the adaptive burn-in phase.\nnthin::Int64 = 500: the iteration sampling frequency.\nsaveXY::Tuple{Bool,Int64} = (false, 1_000): first index to \n\nsave (or not) data augmented histories, second index for sampling frequency.\n\nsaveDM::Tuple{Bool,Int64} = (false, 1_000): a tuple of length 2: first is a boolean to save (or not) data augmented deterministic effects, second an integer for sampling frequency.\nωxprior::NTuple{2,Float64} = (0.,10.): a tuple of length 2 for the normal prior of ωx, first the mean, second the variance.\nω1prior::NTuple{2,Float64} = (0.,10.): a tuple of length 2 for the normal prior of ω1, first the mean, second the variance.\nω0prior::NTuple{2,Float64} = (0.,10.): a tuple of length 2 for the normal prior of ω0, first the mean, second the variance.\nσ²prior::Float64 = 1e-1: a float for the mean of the exponential prior for σ².\nλprior::Float64 = 1e-1: a float for the mean of the exponential prior for both λs.\nweight::NTuple{5,Float64} = (0.15,0.05,0.02,0.02,5e-3): a tuple of length 5 specifying the probabilities to update σ², ωx, ω1 & ω0, and λ1 & λ0 respectively.\nλ1i::Float64 = 1.0: a float for the starting value for λ1.\nλ0i::Float64 = 0.5: a float for the starting value for λ0.\nωxi::Float64 = 0.0: a float for the starting value for ωx.\nω1i::Float64 = 0.0: a float for the starting value for ω1.\nω0i::Float64 = 0.0: a float for the starting value for ω0.\nfix_ωx::Bool = false: a boolean to make inference without ωx.\nfix_ω1::Bool = false: a boolean to make inference without ω1.\nfix_ω0::Bool = false: a boolean to make inference without ω0.\ndelim::Char= '\t': for ddlm.\neol::Char= ' ': for ddlm.\nscreen_print::Int64 = 5: seconds to wait to update screen log.\n\n...\n\n...\n\nReturned values\n\nArray of the mcmc parameters.\n\n...\n\n\n\n\n\ntribe(tip_values::Dict{Int64,Float64}, \n      tip_areas ::Dict{Int64,Array{Int64,1}},\n      tree      ::rtree, \n      bts       ::Array{Float64,1},\n      out_file  ::String;\n      min_dt    ::Float64           = 0.01,\n      niter     ::Int64             = 500_000,\n      nburn     ::Int64             = 500_000,\n      nthin     ::Int64             = 1_000,\n      saveXY    ::Tuple{Bool,Int64} = (false, 1_000),\n      saveDM    ::Tuple{Bool,Int64} = (false, 1_000),\n      ωxprior   ::NTuple{2,Float64} = (0.,10.),\n      ω1prior   ::NTuple{2,Float64} = (0.,10.),\n      ω0prior   ::NTuple{2,Float64} = (0.,10.),\n      σ²prior   ::Float64           = 1e-1,\n      λprior    ::Float64           = 1e-1,\n      weight    ::NTuple{5,Float64} = (0.15,0.05,0.02,0.02,5e-3),\n      λ1i       ::Float64           = 1.0,\n      λ0i       ::Float64           = 0.4,\n      ωxi       ::Float64           = 0.,\n      ω1i       ::Float64           = 0.,\n      ω0i       ::Float64           = 0.,\n      fix_ωx    ::Bool              = false,\n      fix_ω1    ::Bool              = false,\n      fix_ω0    ::Bool              = false,\n      delim     ::Char              = '\t',\n      eol       ::Char              = '\r')\n\nRun tribe for simulations. Wrapper for all functions.\n\n\n\n\n\ntribe(out_file::String;\n      niter   ::Int64             = 500_000,\n      nburn   ::Int64             = 500_000,\n      nthin   ::Int64             = 1_000,\n      ωxprior ::NTuple{2,Float64} = (0.,10.),\n      ω1prior ::NTuple{2,Float64} = (0.,10.),\n      ω0prior ::NTuple{2,Float64} = (0.,10.),\n      σ²prior ::Float64           = 1e-1,\n      λprior  ::Float64           = 1e-1,\n      weight  ::NTuple{4,Float64} = (0.15,0.05,0.02,0.02),\n      σ²i     ::Float64           = 1.,\n      ωxi     ::Float64           = 0.,\n      ω1i     ::Float64           = 0.01,\n      ω0i     ::Float64           = 0.01,\n      λ1i     ::Float64           = 1.0,\n      λ0i     ::Float64           = 0.2,\n      fix_ωx  ::Bool              = false,\n      fix_ω1  ::Bool              = false,\n      fix_ω0  ::Bool              = false)\n\nRun tribe under the prior. Wrapper for all functions.\n\n\n\n\n\n","category":"function"},{"location":"man/tribe/#Tapestree.TRIBE.simulate_tribe","page":"TRIBE","title":"Tapestree.TRIBE.simulate_tribe","text":"simulate_tribe(X_initial::Float64,\n               nareas   ::Int64,\n               tree_file::String;\n               ωx       = 0.0,\n               σ²       = 0.5,\n               λ1       = 0.5,\n               λ0       = 0.2,\n               ω1       = 0.0,\n               ω0       = 0.0,\n               const_δt = 1e-4)\n\nSimulate tribe model.\n\n...\n\nArguments\n\nX_initial::Float64: trait starting value.\nnareas   ::Int64: number of areas.\ntree_file::String: full path to tree file.\nωx::Float64 = 0.0: simulated value of ω_x.\nσ²::Float64 = 0.5: simulated value of σ^2.\nω1::Float64 = 0.0: simulated value of ω_1.\nω0::Float64 = 0.0: simulated value of ω_0.\nλ1::Float64 = 0.5: simulated value of λ_1.\nλ0::Float64 = 0.2: simulated value of λ_0.\nconst_δt = 1e-4: # delta t used to approximate the simulation (lower values\n\nare more accurate but at a computation cost). ...\n\n\n\n\n\n","category":"function"},{"location":"man/insane/fbdd/#Fossilized-birth-death-diffusion-process","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion process","text":"","category":"section"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"This model follows from the episodic fossilized birth-death model, where we relax the assumption of constant rates for instead allowing the per-lineage instantaneous speciation rates lambda(t) and extinction rates mu(t) to follow separate Geometric Brownian motions (GBM), such that","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"d(textln(lambda(t)) = alpha_lambda dt + sigma_lambda d W(t)\nd(textln(mu(t)) = alpha_mu dt + sigma_mu d W(t)","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"where W(t) is the Wiener process (i.e., standard Brownian motion), alpha_lambda and alpha_mu are the drift in speciation and extinction, and sigma_lambda and sigma_mu are the diffusion for speciation and extinction, respectively. ","category":"page"},{"location":"man/insane/fbdd/#Simulations","page":"Fossilized birth-death diffusion","title":"Simulations","text":"","category":"section"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"One can specify a time or a number of lineages to simulate under the FBDD. For example, for 50 species","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"sim_gbmfbd(50, λ0 = 1.0, μ0 = 0.9, αλ = 0.0, αμ = 0.0, σλ = 0.1, σμ = 0.1),","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"Or one can simulate for a given amount of time, say, 10 time units","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"sim_gbmfbd(10.0, 1.0, 0.9, 0.0, 0.0, 0.1, 0.1),","category":"page"},{"location":"man/insane/fbdd/#Inference","page":"Fossilized birth-death diffusion","title":"Inference","text":"","category":"section"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"One can perform inference using:","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"r, tv = insane_gbmfbd(tree,\n                      nburn    = 1_000,\n                      niter    = 50_000,\n                      nthin    = 50, \n                      ofile    = \"<directory>\",\n                      λ0_prior = (0.05, 148.41),\n                      μ0_prior = (0.05, 148.41),\n                      αλ_prior = (0.0, 1.0),\n                      αμ_prior = (0.0, 1.0),\n                      σλ_prior = (0.05, 0.05),\n                      σμ_prior = (3.0, 0.1),\n                      tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"where we have log-normal priors on the initial (root) values for lambda_0 and mu_0, normal priors on the drift for speciation and extinction, and Inverse Gamma prior for the speciation and extinction diffusion rates. Usually, an informative prior such as σμ_prior = (3.0, 0.1) or more is often needed.","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"If additional occurrences exist, they can be added as specified in Adding external fossil occurrences","category":"page"},{"location":"man/insane/fbdd/","page":"Fossilized birth-death diffusion","title":"Fossilized birth-death diffusion","text":"Full documentation","category":"page"},{"location":"man/insane/fbdd/#Tapestree.INSANE.sim_gbmfbd","page":"Fossilized birth-death diffusion","title":"Tapestree.INSANE.sim_gbmfbd","text":"sim_gbmfbd(n       ::Int64;\n           λ0      ::Float64         = 1.0,\n           μ0      ::Float64         = 0.2,\n           αλ      ::Float64         = 0.0,\n           αμ      ::Float64         = 0.0,\n           σλ      ::Float64         = 0.1,\n           σμ      ::Float64         = 0.1,\n           ψ       ::Vector{Float64} = [0.1],\n           ψts     ::Vector{Float64} = Float64[],\n           init    ::Symbol          = :stem,\n           δt      ::Float64         = 1e-3,\n           nstar   ::Int64           = 2*n,\n           p       ::Float64         = 5.0,\n           warnings::Bool            = true,\n           maxt    ::Float64         = δt*1e6)\n\nSimulate iTfbd according to geometric Brownian motions for birth and death rates. Note that it will not necessarily evolve along all of the epochs.\n\n\n\n\n\nsim_gbmfbd(t   ::Float64;\n           λ0  ::Float64         = 1.0,\n           μ0  ::Float64         = 0.2,\n           αλ  ::Float64         = 0.0,\n           αμ  ::Float64         = 0.0,\n           σλ  ::Float64         = 0.1,\n           σμ  ::Float64         = 0.1,\n           ψ   ::Vector{Float64} = [0.1],\n           ψts ::Vector{Float64} = Float64[],\n           δt  ::Float64         = 1e-3,\n           nlim::Int64           = 10_000,\n           init::Symbol          = :crown)\n\nSimulate iTfbd according to geometric Brownian motions for birth and death rates.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/fbdd/#Tapestree.INSANE.insane_gbmfbd","page":"Fossilized birth-death diffusion","title":"Tapestree.INSANE.insane_gbmfbd","text":"insane_gbmfbd(tree    ::sTf_label;\n              λ0_prior::NTuple{2,Float64}     = (0.1, 148.41),\n              μ0_prior::NTuple{2,Float64}     = (0.1, 148.41),\n              αλ_prior::NTuple{2,Float64}     = (0.0, 1.0),\n              αμ_prior::NTuple{2,Float64}     = (0.0, 1.0),\n              σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n              σμ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n              ψ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n              ψ_epoch ::Vector{Float64}       = Float64[],\n              f_epoch ::Vector{Int64}         = Int64[0],\n              niter   ::Int64                 = 1_000,\n              nthin   ::Int64                 = 10,\n              nburn   ::Int64                 = 200,\n              nflush  ::Int64                 = nthin,\n              ofile   ::String                = string(homedir(), \"/fbdd\"),\n              ϵi      ::Float64               = 0.2,\n              λi      ::Float64               = NaN,\n              μi      ::Float64               = NaN,\n              ψi      ::Float64               = NaN,\n              αλi     ::Float64               = 0.0,\n              αμi     ::Float64               = 0.0,\n              σλi     ::Float64               = 1e-3,\n              σμi     ::Float64               = 1e-3,\n              pupdp   ::NTuple{7,Float64}     = (0.01, 0.01, 0.01, 0.01, 0.1, 0.1, 0.2),\n              δt      ::Float64               = 1e-3,\n              survival::Bool                  = true,\n              mxthf   ::Float64               = 0.1,\n              prints  ::Int64                 = 5,\n              stnλ    ::Float64               = 0.5,\n              stnμ    ::Float64               = 0.5,\n              tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for fossilized birth-death diffusion fbdd.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/iplots/#Insane-plots","page":"Plotting","title":"Insane plots","text":"","category":"section"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"Insane holds recipes to plot phylogenetic trees, results and perform aggregating functions. The output will rely in the number and type of arguments you provide.","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"First, however, we need to load the Plots package","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"using Plots","category":"page"},{"location":"man/insane/iplots/#Insane-plots-across-all-tree-types","page":"Plotting","title":"Insane plots across all tree types","text":"","category":"section"},{"location":"man/insane/iplots/#Simple-tree-plot","page":"Plotting","title":"Simple tree plot","text":"","category":"section"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"The most basic plot function simply plots the tree:","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(tree)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf1)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"One can reorder the tree according to balance (have one daughter always have the largest number of tips) by using reorder!(tree), which orders in place the tree and helps in visualization.","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"If one has a tree vector, we could, for example, sample 4 of them at random and simply plot them together using","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"ti = rand(tv,4)\n\np0 = plot(ti[1])\np1 = plot(ti[2])\np2 = plot(ti[3])\np3 = plot(ti[4])\n\nplot(p0, p1, p2, p3)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf2)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"If the tree is of type sT_label or sTf_label, labels will be shown automatically, but you can toggle this off with showlabels = false.","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"One can also plot the tree radially (as a fan) using","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(tree, type = :radial)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf3)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"For trees with fossils the fossilization events are shown as default, but one can change this. For instance, one can also add symbols in the plot for speciation and extinction events beside fossilization events. This can be set by the shownodes keyword, which receives a Boolean Tuple of size 3, specifying, if speciation, extinction and fossil events should be shown, respectively. In the same order, with the keyword shapes you specify a vector of Symbols with the shape (e.g., :circle), and, finally the keyword colors, in the same order, specifies the colors for each shape.","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(tree, shownodes = (true, true, true), \n           shapes = [:circle, :circle, :square],\n           shsizes = [3.0, 3.0, 3.0])","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf4)","category":"page"},{"location":"man/insane/iplots/#LTT-and-DTT-plots","page":"Plotting","title":"LTT and DTT plots","text":"","category":"section"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"We can plot the LTT or DTT by using the ltt result (of type Ltt, check (check  Basic tree information)) as input:","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(ltt(tree), linewidth = 2.0)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf5)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"Moreover, if we input a vector of Ltt we will plot each LTT individually, or, better, if we add a decimal number argument, it will use it as sampling frequency through time and return the mean and desired quantiles of lineage or diversity through time using the arguments q0 and q1 (by default q0 = [0.025, 0.975] and q1 = [0.25, 0.75]):","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"lttv = ltt(tv)\nplot(lttv, 0.1)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf6)","category":"page"},{"location":"man/insane/iplots/#Insane-plots-for-trees-with-diffusion","page":"Plotting","title":"Insane plots for trees with diffusion","text":"","category":"section"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"These plotting functions are specific to BDD, FBDD or DBM type trees (i.e., of iT or sTxs supertype).","category":"page"},{"location":"man/insane/iplots/#Plot-the-rates-on-the-tree","page":"Plotting","title":"Plot the rates on the tree","text":"","category":"section"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"To \"paint\" the tree with the instantaneous lineage-specific rates of speciation lambda(t), we can use:","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(tree, birth)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf7)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"info: Info\nbirth, which stands for \"birth rates\", is a convenience wrapper around exp.(lλ(tree)): it extracts the log-speciation vector from a give iT tree using lλ, and then returns the exponential.","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"This plotting function also allows to plot the death rates (only where extinction is also a diffusion, i.e., iTbd) using","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(tree, death)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf8) where death, which stands for \"death rates\" (i.e., extinction) is a wrapper around exp.(lμ(tree)).","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"In general, this plotting recipe receives a tree and a function that is applied recursively to paint the tree. Thus, we can use any custom made function that extracts information from the tree. Some predefined ones are:","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"logbirth: log-(speciation) birth rates\nlogdeath: log-(extinction) death rates \nturnover: turnover (extinction/speciation) rates\ndiversification: net diversification (speciation - extinction) rates\ntrait: trait values\nevorate: evolutionary rates sigma^2(t)\nlogevorate: log-evolutionary rates sigma^2(t)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"info: Info\nOne can also plot these trees radially using the type = :radial.","category":"page"},{"location":"man/insane/iplots/#Plot-the-underlying-rates-along-a-tree","page":"Plotting","title":"Plot the underlying rates along a tree","text":"","category":"section"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"To plot how rates evolve across time, that is, to plot the rates in the y axis, one simply changes the argument order:","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(birth, tree)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf9)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"One can paint these rates by another variable, say, extinction rates, using","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(birth, tree, zf = death)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf10)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"Similarly, one can plot the average for a tree (or other aggregating function as median, geometric mean, etc.) and custom quantiles (as in LTT and DTT plots) for a given tree by adding a decimal number argument representing the sampling frequency through time.","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(birth, 0.1, tree)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf11)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"To change the aggregating function, one can modify the function t_af (by default t_af = mean), to the desired one.","category":"page"},{"location":"man/insane/iplots/#Plot-the-rates-across-tree-vectors","page":"Plotting","title":"Plot the rates across tree vectors","text":"","category":"section"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"Often one would like to plot the average rates across a series of data augmented trees. This can be done by adding a decimal number argument (and, using a tree vector as input). For instance, to estimate average speciation rates (using wrapping function birth) through time across tree vector tv, every 01 time units, we use:","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"plot(birth, 0.1, tv)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"(Image: pf12)","category":"page"},{"location":"man/insane/iplots/","page":"Plotting","title":"Plotting","text":"One can choose the function to aggregate rates across lineages for each single tree using af (by default af = mean, and then to aggregate these tree averages using the vaf function (by default vaf = x -> quantile(x, 0.5), that is, the median).","category":"page"},{"location":"#Tapestree.jl","page":"Home","title":"Tapestree.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unraveling the evolutionary tapestry:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tapestree is a  Julia package of phylogenetic analyses of  diversification, trait and biogeographic dynamics.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tapestree currently holds the following phylogenetic models:","category":"page"},{"location":"#INSANE-models-using-Bayesian-Data-augmentation-(DA)","page":"Home","title":"INSANE models using Bayesian Data augmentation (DA)","text":"","category":"section"},{"location":"#Diversification-(birth-death)-models","page":"Home","title":"Diversification (birth-death) models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\"Constant Birth-Death\" (CBD): implements a birth-death model of constant speciation rates and extinction rates under a Bayesian data augmentation algorithm, as described in Quintero, I., Lartillot, N., & Morlon, H. (2024). \"Imbalanced speciation pulses sustain the radiation of mammals\". Science, 384 (6699) 1007-1012  https://doi.org/10.1126/science.adj2793\n\"Birth-Death Diffusion\" (BDD): implements birth-death models where speciation rates follow a geometric Brownian motion with either no extinction, constant extinction, constant turnover, informed extinction or extinction diffusion under a Bayesian data augmentation algorithm, as described in Quintero, I., Lartillot, N., & Morlon, H. (2024). \"Imbalanced speciation pulses sustain the radiation of mammals\". Science, 384 (6699) 1007-1012  https://doi.org/10.1126/science.adj2793\n\"Constant Fossilized Birth-Death\" (CFBD): implements a birth-death model of constant speciation rates and extinction rates with piece-wise constant temporal changes in fossilization rates under a Bayesian data augmentation algorithm, as described in Quintero, I., Andréoletti, J., Silvestro, D., & Morlon, H. (2025). \"The rise, decline and fall of clades\". BioRxiv  https://doi.org/10.1101/2025.03.20.644316\n\"Fossilized Birth-Death Diffusion\" (FBDD): implements a fossilized birth-death model where speciation and extinction rates follow separate geometric Brownian motions under a Bayesian data augmentation algorithm, as described in Quintero, I., Andréoletti, J., Silvestro, D., & Morlon, H. (2025). \"The rise, decline and fall of clades\". BioRxiv  https://doi.org/10.1101/2025.03.20.644316","category":"page"},{"location":"#Diffused-Brownian-motion-(DBM)-model","page":"Home","title":"Diffused Brownian motion (DBM) model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DBM implements a trait evolution model where trait and its underlying rates follow separate geometric Brownian motions under a Bayesian data augmentation algorithm, as described in Quintero, I. (2025). The diffused evolutionary dynamics of morphological novelty. Proceedings of the National Academy of Sciences, U.S.A. 122 (18) e2425573122, https://doi.org/10.1073/pnas.2425573122.","category":"page"},{"location":"#Environmental-and-State-dependent-Speciation-and-Extinction-(ESSE)-model","page":"Home","title":"Environmental and State dependent Speciation and Extinction (ESSE) model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ESSE implements a joint geographic and environmental dependent model of diversification as described in Quintero, I., Landis, M. J., Jetz, W., & Morlon, H. (2022). The build-up of the present-day tropical diversity of tetrapods. Proceedings of the National Academy of Sciences, 2023. 120 (20) e2220672120. https://doi.org/10.1073/pnas.2220672120","category":"page"},{"location":"#Trait-and-Range-Interspecific-Biogeographic-Evolution-(TRIBE)-model","page":"Home","title":"Trait and Range Interspecific Biogeographic Evolution (TRIBE) model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TRIBE implements a joint model of trait evolution and biogeographic history shaped by biotic interactions under a Bayesian data augmentation algorithm, as described in Quintero, I., & Landis, M. J. (2020). Interdependent phenotypic and biogeographic evolution driven by biotic interactions. Systematic biology, 69 (4), 739-755. https://doi.org/10.1093/sysbio/syz082","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"installation.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"quick_start.md\",\n]\nDepth = 3","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/insane/contents.md\",\n    \"man/tribe.md\",\n    \"man/esse.md\",\n]\nDepth = 2","category":"page"},{"location":"#Issues","page":"Home","title":"Issues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Submit them to Issues","category":"page"}]
}
