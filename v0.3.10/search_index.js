var documenterSearchIndex = {"docs":
[{"location":"man/esse/#ESSE","page":"ESSE","title":"ESSE","text":"","category":"section"},{"location":"man/esse/#Reference","page":"ESSE","title":"Reference","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Quintero, I., Landis, M. J., Jetz, W., & Morlon, H. (2022). The build-up of the present-day tropical diversity of tetrapods. Proceedings of the National Academy of Sciences, 2023. 120 (20) e2220672120. https://doi.org/10.1073/pnas.2220672120","category":"page"},{"location":"man/esse/#Example","page":"ESSE","title":"Example","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"In this example we run some random data for 50 species across 2 areas, where each area has a specific covariate that affects speciation and we also allow for 2 hidden states.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Open Julia and load the Tapestree package: ","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"using Tapestree","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify the path to the phylogenetic tree (in a format that ape::read.tree() can read):","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"tree_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"tree_50.tre\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify state data. Data should be a .txt file where each row is a species,  first the species name that matches the tree tip labels and each subsequent column specifying presence or absence in a given area with 0 or 1,  respecitvely. Open st2_data.txt in the data folder to see an example for 2 areas.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"states_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"st2_data.txt\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify covariate data y = f(x). Data should be a .txt file where the  first column is time x in backward fashion (the present is 0 and the  past is  0), and the subsequent columns are the respective time covariates for each area f(x). If there is only one covariate, the same is used across all areas, if not, the number of covariates should match the specific model.  More than one covariate per area is allowed, and in the case of covariates  affecting colonization rates, they should match the number of possible  colonization parameters between all areas. Open env_data_2.txt in the data folder to see an example for 2 covariates for 2 areas.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"envdata_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"env_data_2.txt\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify output MCMC file (homedir() is an alias to your home folder)","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"out_file = *(homedir(),\"...\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Specify the (optional) output file (homedir() is an alias to your home  folder) for the node marginal probabilities. ","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"out_states = *(homedir(),\"...\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Run the esse() (ESSE: Environmental and State dependent Speciation and  Extinction) model, with covariates affecting speciation rates:","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"esse(tree_file, out_file, 2, envdata_file = envdata_file, \n  states_file = states_file, out_states = out_states, cov_mod = (\"s\",))","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"If one would like to make the covariates affect other rates, such as dispersal, in addition to speciation rates, one would specify the following covariate model cov_mod = (\"s\",\"g\"). Note however that this has not been validated.  Moreover, covariate effect on extinction is non retrievable from extant-only phylogenetic trees.","category":"page"},{"location":"man/esse/#Parallel-MC3","page":"ESSE","title":"Parallel MC3","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"It is encouraged to use Metropolis coupled MCMC (MC3) for more robust  convergence (the posterior surfaced is highly peaked).","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Load the Distributed package, set the number of processors for Julia, and make Tapestree available to all (see the Distributed  package for more information). Below we add 3 processors.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"using Distributed\naddprocs(3)\n@everywhere using Tapestree","category":"page"},{"location":"man/esse/#Set-parameter-constraints","page":"ESSE","title":"Set parameter constraints","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"To constrain parameters to be equal to one another or to fix them to be 0,  it is necessary to create equalities between parameters and pass them as an  argument. In general parameters are specified as follows:    \"<parameter name>_<area>_<hidden state>\"","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"Speciation is \"lambda\" (e.g. speciation rate for area A and hidden state 0: lambda_A_0)\nLocal extinction is \"loss\" (e.g. local extinction rate for area B and hidden state 1: loss_B_1)\ncolonization is \"gain\" (e.g. gain rate from A -> B and hidden state 1: gain_AB_1)\nthe effect of the covariate is \"beta_<effect parameter name>\" (e.g. effect of first covariate on speciation in area A and hidden state 0: beta_lambda_1_A_0 - here the 1 after the lambda is because is the first covariate)\ntransition between hidden states is \"q\" (e.g. transition rate from hidden state 0 -> 1 and hidden state 1: q_01). ","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"You have to make sure that the given constraints apply to the specification of  model. In the following example, we constraint local and global extinction rates to be the same across 2 areas and 2 hidden states , and constrain the hidden states transition rates.","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"cpar = (\"q_01 = q_10\",\n        \"loss_A_0 = mu_A_0\",\n        \"loss_B_0 = mu_B_0\",\n        \"loss_A_1 = mu_A_1\",\n        \"loss_B_1 = mu_B_1\")","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"We now run esse, using MC3 with Metropolis-Hastings MCMC (here using 3 parallel chains).","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"esse(tree_file, out_file, 2,\n     envdata_file = envdata_file,\n     states_file  = states_file, \n     out_states   = out_states,\n     constraints  = cpar,\n     cov_mod      = (\"s\",),\n     ncch         = 3,\n     parallel     = true,\n     niter        = 5_000,\n     nthin        = 100,\n     dt           = 0.8,\n     nburn        = 1_000, \n     mc           = \"mh\",\n     node_ps      = (true, 100))","category":"page"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"For optional (keyword) arguments, see below","category":"page"},{"location":"man/esse/#Function-Documentation","page":"ESSE","title":"Function Documentation","text":"","category":"section"},{"location":"man/esse/","page":"ESSE","title":"ESSE","text":"esse\nsimulate_sse","category":"page"},{"location":"man/esse/#Tapestree.ESSE.esse","page":"ESSE","title":"Tapestree.ESSE.esse","text":"esse(tree_file   ::String,\n     out_file    ::String,\n     h           ::Int64;\n     states_file ::String            = \"NaN\",\n     envdata_file::String            = \"NaN\",\n     cov_mod     ::NTuple{M,String}  = (\"\",),\n     node_ps     ::Tuple{Bool,Int64} = (true, 10),\n     out_states  ::String            = \"\",\n     constraints ::NTuple{N,String}  = (\" \",),\n     mvpars      ::NTuple{O,String}  = (\" \",),\n     niter       ::Int64             = 10_000,\n     nthin       ::Int64             = 10,\n     nburn       ::Int64             = 200,\n     tune_int    ::Int64             = 100,\n     nswap       ::Int64             = 10,\n     ncch        ::Int64             = 1,\n     parallel    ::Bool              = ncch > 1,\n     dt           ::Float64          = 0.2,\n     ntakew      ::Int64             = 100,\n     winit       ::Float64           = 2.0,\n     scale_y     ::NTuple{2,Bool}    = (true, false),\n     algorithm   ::String            = \"pruning\",\n     mc          ::String            = \"slice\",\n     λpriors     ::Float64           = .1,\n     μpriors     ::Float64           = .1,\n     gpriors     ::Float64           = .1,\n     lpriors     ::Float64           = .1,\n     qpriors     ::Float64           = .1,\n     βpriors     ::NTuple{2,Float64} = (0.0, 10.0),\n     hpriors     ::Float64           = .1,\n     optimal_w   ::Float64           = 0.8,\n     tni         ::Float64           = 1.0,\n     obj_ar      ::Float64           = 0.6,\n     screen_print::Int64             = 5,\n     Eδt         ::Float64           = 1e-3,\n     ti          ::Float64           = 0.0,\n     ρ           ::Array{Float64,1}  = [1.0]) where {M,N,O}\n\nRun geographic esse. See tutorial for how these files should be specified.\n\nArguments\n\ntree_file::String: full path to tree file.\nout_file::String: full path to write MCMC output.\nh::Int64: number of hidden states.\nstates_file ::String = \"NaN\": full path to states file. If \"NaN\", no \n\nobserved states are used (only hidden states).\n\nenvdata_file::String = \"NaN\": full path to covariates file. If \"NaN\", no \n\ncovariates are used (i.e., constant rates).\n\ncov_mod::NTuple{M,String} = (\"\",): specifies which rates are affected by \n\ncovariates: s for speciation, e for extinction, and g for colonization. More than 1 is possible.\n\nnode_ps::Tuple{Bool,Int64} = (true, 10): first index specifies if posterior\n\nmarginal probabilities for nodes should be computed, second index the number of iterations to be computed. \n\nout_states::String = \"\": full path to write node probabilities output.\nconstraints::NTuple{N,String} = (\" \",): constraints for the model \n\nparameters.\n\nmvpars::NTuple{O,String} = (\" \",): which parameters should be multivariate \n\nwhen using slice sampling for better convergence.\n\nniter::Int64 = 10_000: number of iterations.\nnthin::Int64 = 10: frequency at which to record MCMC state.\nnburn::Int64 = 200: number of iterations to discard as burn-in.\ntune_int::Int64 = 100: number of iterations during nburn to tune proposal\n\nwindow for MH.\n\nnswap::Int64 = 10: every iteration to try to swap chain likelihoods in MC3.\nncch::Int64 = 1: number of chains.\nparallel::Bool = false: if parallel run.\ndt::Float64 = 0.2: temperature for MC3.\nntakew::Int64 = 100: number of iterations from nburn to tune the window\n\nfor slice sampling.\n\nwinit::Float64 = 2.0: initial window for slice sampling.\nscale_y::NTuple{2,Bool} = (true, false): first index if scale covariates y\n\nto [0,1], second, if scale covariates y all together between [0,1].\n\nalgorithm::String = \"pruning\": likelihood algorithm between pruning \n\n(recommended) or flow.\n\nmc::String = \"slice\": which sampling slice (slice-sampling) or \n\nmh (metropolis-hasting).\n\nλpriors::Float64 = 0.1: rate of Exponential prior for speciation.\nμpriors::Float64 = 0.1: rate of Exponential prior for global extinction.\ngpriors::Float64 = 0.1: rate of Exponential prior for colonization.\nlpriors::Float64 = 0.1: rate of Exponential prior for local extinction.\nqpriors::Float64 = 0.1: rate of Exponential prior for hidden state \n\ntransitions.\n\nβpriors::NTuple{2,Float64} = (0.0, 10.0): mean and variance of Normal \n\nprior for effect of covariates.\n\nhpriors::Float64 = 0.1: rate of Exponential prior for differences between\n\nhidden states.\n\noptimal_w::Float64 = 0.8: optimal window.\ntni::Float64 = 1.0: initial tuning for rates.\nobj_ar::Float64 = 0.23: objective acceptance rate.\nscreen_print::Int64 = 5: seconds to wait to update screen log.\nEδt::Float64 = 1e-3: for flow algorithm.\nti::Float64 = 0.0: for flow algorithm.\nρ::Array{Float64,1} = [1.0]: sampling fraction for each state (each area and\n\nwidespread).\n\nReturned values\n\nArray of the mcmc parameters.\n\n\n\n\n\nesse(tv          ::Dict{Int64,Array{Float64,1}},\n     ed          ::Array{Int64,2}, \n     el          ::Array{Float64,1}, \n     x           ::Array{Float64,1},\n     y           ::Array{Float64,L}, \n     cov_mod     ::NTuple{M,String},\n     out_file    ::String,\n     h           ::Int64;\n     constraints ::NTuple{N,String}  = (\" \",),\n     mvpars      ::NTuple{O,String}  = (\"lambda = beta\",),\n     niter       ::Int64             = 10_000,\n     nthin       ::Int64             = 10,\n     nburn       ::Int64             = 200,\n     ncch        ::Int64             = 1,\n     ntakew      ::Int64             = 100,\n     winit       ::Float64             = 2.0,\n     scale_y     ::NTuple{2,Bool}    = (true, false),\n     algorithm   ::String            = \"pruning\",\n     λpriors     ::Float64           = .1,\n     μpriors     ::Float64           = .1,\n     gpriors     ::Float64           = .1,\n     lpriors     ::Float64           = .1,\n     qpriors     ::Float64           = .1,\n     βpriors     ::NTuple{2,Float64} = (0.0, 10.0),\n     hpriors     ::Float64           = .1,\n     optimal_w   ::Float64           = 0.8,\n     screen_print::Int64             = 5,\n     Eδt         ::Float64           = 1e-3,\n     ti          ::Float64           = 0.0,\n     ρ           ::Array{Float64,1}  = [1.0]) where {L,M,N,O}\n\nWrapper for running a esse model from simulations.\n\n\n\n\n\n","category":"function"},{"location":"man/esse/#Tapestree.ESSE.simulate_sse","page":"ESSE","title":"Tapestree.ESSE.simulate_sse","text":"simulate_sse(λ          ::Array{Float64,1},\n             μ          ::Array{Float64,1},\n             l          ::Array{Float64,1},\n             g          ::Array{Float64,1},\n             q          ::Array{Float64,1},\n             t          ::Float64;\n             δt         ::Float64 = 1e-4,\n             ast        ::Int64   = 0,\n             nspp_max   ::Int64   = 100_000,\n             retry_ext  ::Bool    = true,\n             rejectel0  ::Bool    = true,\n             verbose    ::Bool    = true,\n             rm_ext     ::Bool    = true,\n             states_only::Bool    = false, \n             start      ::Symbol  = :crown)\n\nSimulate tree according to the geographic esse model. The number of areas  and hidden states is inferred from the parameter vectors, but they must be  consistent between them and with the covariates. See tutorial for an example.\n\nArguments\n\nλ::Array{Float64,1}: rates for within-area and between-area speciation.\nμ::Array{Float64,1}: per-area extinction rates when it leads to global \n\nextinction.\n\nl::Array{Float64,1}: per-area extinction rates when it leads to local \n\nextinction.\n\ng::Array{Float64,1}: colonization rates between areas. \nq::Array{Float64,1}: transition rates between hidden states.\nt::Float64: simulation time.\nδt::Float64 = 1e-4: time step to perform simulations. Smaller more precise \n\nbut more computationally expensive.\n\nast::Int64 = 0: initial state. 0 specifies random sampling based on the \n\ninput parameters.\n\nnspp_max::Int64 = 100_000: maximum number of species allowed to stop \n\nsimulation.\n\nretry_ext::Bool = true: automatically restart simulation if simulation goes\n\nextinct.\n\nrejectel0::Bool = true: reject simulations where there are edges of 0 \n\nlength.\n\nverbose::Bool = true: print messages.\nrm_ext::Bool = true: remove extinct taxa from output.\nstates_only::Bool = false: if only return tip states (faster).\nstart::Symbol  = :crown: if crown, starts after a speciation event with \n\ntwo lineages, if stem, starts with one lineage.\n\nReturned values\n\nDictionary with tip number and corresponding state.\nArray with parent -> daughter edges.\nArray with edge lengths.\nNumber of maximum species.\n\n\n\n\n\nsimulate_sse(λ          ::Array{Float64,1},\n             μ          ::Array{Float64,1},\n             l          ::Array{Float64,1},\n             g          ::Array{Float64,1},\n             q          ::Array{Float64,1},\n             β          ::Array{Float64,1},\n             t          ::Float64,\n             x          ::Array{Float64,1},\n             y          ::Array{Float64,N},\n             cov_mod    ::Tuple{Vararg{String}};\n             δt         ::Float64 = 1e-4,\n             ast        ::Int64   = 0,\n             nspp_max   ::Int64   = 100_000,\n             retry_ext  ::Bool    = true,\n             rejectel0  ::Bool    = true,\n             verbose    ::Bool    = true,\n             rm_ext     ::Bool    = true,\n             states_only::Bool    = false,\n             start      ::Symbol  = :crown) where {N}\n\nSimulate tree according to the geographic sse model. The number of areas  and hidden states is inferred from the parameter vectors, but they must be  consistent between them and with the covariates. See tutorial for an example.\n\nArguments\n\nλ::Array{Float64,1}: rates for within-area and between-area speciation.\nμ::Array{Float64,1}: per-area extinction rates when it leads to global \n\nextinction.\n\nl::Array{Float64,1}: per-area extinction rates when it leads to local \n\nextinction.\n\ng::Array{Float64,1}: colonization rates between areas. \nq::Array{Float64,1}: transition rates between hidden states.\nβ::Array{Float64,1}: per-area effect of covariates.\nt::Float64: simulation time.\nx::Array{Float64,1}: times where the covariate y is sampled.\ny::Array{Float64,N}: value of covariates, i.e., f(x). Can be multivariate.\ncov_mod::Tuple{Vararg{String}}: specifies which rates are affected by \n\ncovariates: s for speciation, e for extinction, and g for colonization. More than 1 is possible. \n\nδt::Float64 = 1e-4: time step to perform simulations. Smaller more precise \n\nbut more computationally expensive.\n\nast::Int64 = 0: initial state. 0 specifies random sampling based on the \n\ninput parameters.\n\nnspp_max::Int64 = 100_000: maximum number of species allowed to stop \n\nsimulation.\n\nretry_ext::Bool = true: automatically restart simulation if simulation goes\n\nextinct.\n\nrejectel0::Bool = true: reject simulations where there are edges of 0 \n\nlength.\n\nverbose::Bool = true: print messages.\nrm_ext::Bool = true: remove extinct taxa from output.\nstates_only::Bool = false: if only return tip states (faster).\nstart::Symbol  = :crown: if crown, starts after a speciation event with \n\ntwo lineages, if stem, starts with one lineage.\n\nReturned values\n\nDictionary with tip number and corresponding state.\nArray with parent -> daughter edges.\nArray with edge lengths.\nNumber of maximum species.\n\n\n\n\n\n","category":"function"},{"location":"man/tribe/#TRIBE","page":"TRIBE","title":"TRIBE","text":"","category":"section"},{"location":"man/tribe/#Reference","page":"TRIBE","title":"Reference","text":"","category":"section"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Quintero, I., & Landis, M. J. (2020). Interdependent phenotypic and biogeographic evolution driven by biotic interactions. Systematic biology, 69(4), 739-755. https://doi.org/10.1093/sysbio/syz082","category":"page"},{"location":"man/tribe/#Example","page":"TRIBE","title":"Example","text":"","category":"section"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Open Julia and load the Tapestree package: ","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"using Tapestree","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Specify the path to the phylogenetic tree (in a format that ape::read.tree() can read):","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"finches_tree_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"finches_rescaled.tre\")","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Specify data. Data should be a .txt file where each row is a species, first  the species name that matches the tree tip labels, second the phenotypic data  and then the species presence in each area (0 if absent and 1 if present).  Open finches_pca1.txt in the data folder to see an example.","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"finches_data_file = joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"finches_pca1.txt\")","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Specify output file (homedir() is an alias to your home folder)","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"out_file = *(homedir(),\"...\")","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"Run the tribe() (TRIBE: Trait and Range Interspecific Biogeographic Evolution) model:","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"tribe(finches_tree_file, finches_data_file, out_file)","category":"page"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"For optional (keyword) arguments, see below","category":"page"},{"location":"man/tribe/#Function-Documentation","page":"TRIBE","title":"Function Documentation","text":"","category":"section"},{"location":"man/tribe/","page":"TRIBE","title":"TRIBE","text":"tribe\nsimulate_tribe","category":"page"},{"location":"man/tribe/#Tapestree.TRIBE.tribe","page":"TRIBE","title":"Tapestree.TRIBE.tribe","text":"tribe(tree_file   ::String,\n      data_file   ::String,\n      out_file    ::String;\n      min_dt      ::Float64           = 0.01,\n      niter       ::Int64             = 50_000,\n      nburn       ::Int64             = 50_000,\n      nthin       ::Int64             = 500,\n      saveXY      ::Tuple{Bool,Int64} = (false, 1_000),\n      saveDM      ::Tuple{Bool,Int64} = (false, 1_000),\n      ωxprior     ::NTuple{2,Float64} = (0.,10.),\n      ω1prior     ::NTuple{2,Float64} = (0.,10.),\n      ω0prior     ::NTuple{2,Float64} = (0.,10.),\n      σ²prior     ::Float64           = 1e-1,\n      λprior      ::Float64           = 1e-1,\n      weight      ::NTuple{5,Float64} = (0.15,0.05,0.02,0.02,5e-3),\n      λ1i         ::Float64           = 1.0,\n      λ0i         ::Float64           = 0.5,\n      ωxi         ::Float64           = 0.0,\n      ω1i         ::Float64           = 0.0,\n      ω0i         ::Float64           = 0.0,\n      fix_ωx      ::Bool              = false,\n      fix_ω1      ::Bool              = false,\n      fix_ω0      ::Bool              = false,\n      delim       ::Char              = '\t',\n      eol         ::Char              = '\r',\n      screen_print::Int64             = 5)\n\nRun tribe model. \n\n...\n\nArguments\n\ntree_file::String: full path to tree file.\ndata_file::String: full path to data file.\nout_file::String: full path to write MCMC output.\nmin_dt::Float64 = 0.01: the percentage of tree height allowed for \n\ndiscretization (lower values are more precise but take longer).\n\nniter::Int64 = 50_000: the number of iterations.\nnburn::Int64 = 50_000: the number of iterations in the adaptive burn-in phase.\nnthin::Int64 = 500: the iteration sampling frequency.\nsaveXY::Tuple{Bool,Int64} = (false, 1_000): first index to \n\nsave (or not) data augmented histories, second index for sampling frequency.\n\nsaveDM::Tuple{Bool,Int64} = (false, 1_000): a tuple of length 2: first is a boolean to save (or not) data augmented deterministic effects, second an integer for sampling frequency.\nωxprior::NTuple{2,Float64} = (0.,10.): a tuple of length 2 for the normal prior of ωx, first the mean, second the variance.\nω1prior::NTuple{2,Float64} = (0.,10.): a tuple of length 2 for the normal prior of ω1, first the mean, second the variance.\nω0prior::NTuple{2,Float64} = (0.,10.): a tuple of length 2 for the normal prior of ω0, first the mean, second the variance.\nσ²prior::Float64 = 1e-1: a float for the mean of the exponential prior for σ².\nλprior::Float64 = 1e-1: a float for the mean of the exponential prior for both λs.\nweight::NTuple{5,Float64} = (0.15,0.05,0.02,0.02,5e-3): a tuple of length 5 specifying the probabilities to update σ², ωx, ω1 & ω0, and λ1 & λ0 respectively.\nλ1i::Float64 = 1.0: a float for the starting value for λ1.\nλ0i::Float64 = 0.5: a float for the starting value for λ0.\nωxi::Float64 = 0.0: a float for the starting value for ωx.\nω1i::Float64 = 0.0: a float for the starting value for ω1.\nω0i::Float64 = 0.0: a float for the starting value for ω0.\nfix_ωx::Bool = false: a boolean to make inference without ωx.\nfix_ω1::Bool = false: a boolean to make inference without ω1.\nfix_ω0::Bool = false: a boolean to make inference without ω0.\ndelim::Char= '\t': for ddlm.\neol::Char= ' ': for ddlm.\nscreen_print::Int64 = 5: seconds to wait to update screen log.\n\n...\n\n...\n\nReturned values\n\nArray of the mcmc parameters.\n\n...\n\n\n\n\n\ntribe(tip_values::Dict{Int64,Float64}, \n      tip_areas ::Dict{Int64,Array{Int64,1}},\n      tree      ::rtree, \n      bts       ::Array{Float64,1},\n      out_file  ::String;\n      min_dt    ::Float64           = 0.01,\n      niter     ::Int64             = 500_000,\n      nburn     ::Int64             = 500_000,\n      nthin     ::Int64             = 1_000,\n      saveXY    ::Tuple{Bool,Int64} = (false, 1_000),\n      saveDM    ::Tuple{Bool,Int64} = (false, 1_000),\n      ωxprior   ::NTuple{2,Float64} = (0.,10.),\n      ω1prior   ::NTuple{2,Float64} = (0.,10.),\n      ω0prior   ::NTuple{2,Float64} = (0.,10.),\n      σ²prior   ::Float64           = 1e-1,\n      λprior    ::Float64           = 1e-1,\n      weight    ::NTuple{5,Float64} = (0.15,0.05,0.02,0.02,5e-3),\n      λ1i       ::Float64           = 1.0,\n      λ0i       ::Float64           = 0.4,\n      ωxi       ::Float64           = 0.,\n      ω1i       ::Float64           = 0.,\n      ω0i       ::Float64           = 0.,\n      fix_ωx    ::Bool              = false,\n      fix_ω1    ::Bool              = false,\n      fix_ω0    ::Bool              = false,\n      delim     ::Char              = '\t',\n      eol       ::Char              = '\r')\n\nRun tribe for simulations. Wrapper for all functions.\n\n\n\n\n\ntribe(out_file::String;\n      niter   ::Int64             = 500_000,\n      nburn   ::Int64             = 500_000,\n      nthin   ::Int64             = 1_000,\n      ωxprior ::NTuple{2,Float64} = (0.,10.),\n      ω1prior ::NTuple{2,Float64} = (0.,10.),\n      ω0prior ::NTuple{2,Float64} = (0.,10.),\n      σ²prior ::Float64           = 1e-1,\n      λprior  ::Float64           = 1e-1,\n      weight  ::NTuple{4,Float64} = (0.15,0.05,0.02,0.02),\n      σ²i     ::Float64           = 1.,\n      ωxi     ::Float64           = 0.,\n      ω1i     ::Float64           = 0.01,\n      ω0i     ::Float64           = 0.01,\n      λ1i     ::Float64           = 1.0,\n      λ0i     ::Float64           = 0.2,\n      fix_ωx  ::Bool              = false,\n      fix_ω1  ::Bool              = false,\n      fix_ω0  ::Bool              = false)\n\nRun tribe under the prior. Wrapper for all functions.\n\n\n\n\n\n","category":"function"},{"location":"man/tribe/#Tapestree.TRIBE.simulate_tribe","page":"TRIBE","title":"Tapestree.TRIBE.simulate_tribe","text":"simulate_tribe(X_initial::Float64,\n               nareas   ::Int64,\n               tree_file::String;\n               ωx       = 0.0,\n               σ²       = 0.5,\n               λ1       = 0.5,\n               λ0       = 0.2,\n               ω1       = 0.0,\n               ω0       = 0.0,\n               const_δt = 1e-4)\n\nSimulate tribe model.\n\n...\n\nArguments\n\nX_initial::Float64: trait starting value.\nnareas   ::Int64: number of areas.\ntree_file::String: full path to tree file.\nωx::Float64 = 0.0: simulated value of ω_x.\nσ²::Float64 = 0.5: simulated value of σ^2.\nω1::Float64 = 0.0: simulated value of ω_1.\nω0::Float64 = 0.0: simulated value of ω_0.\nλ1::Float64 = 0.5: simulated value of λ_1.\nλ0::Float64 = 0.2: simulated value of λ_0.\nconst_δt = 1e-4: # delta t used to approximate the simulation (lower values\n\nare more accurate but at a computation cost). ...\n\n\n\n\n\n","category":"function"},{"location":"#Tapestree.jl","page":"Home","title":"Tapestree.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unraveling the evolutionary tapestry: Tapestree is a  Julia package of phylogenetic analyses of  diversification, trait and biogeographic dynamics.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tapestree currently holds the following phylogenetic models:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"Diffused Brownian motion\" (DBM): implements speciation rates following a geometric Brownian motion with no extinction, constant extinction, constant turnover or extinction diffusion as described in Quintero, I. (in press). \"The diffused evolutionary dynamics of morphological novelty\". Proceedings of the National Academy of Sciences.\n\"Birth-Death Diffusion\" (BDD): implements speciation rates following a geometric Brownian motion with no extinction, constant extinction, constant turnover or extinction diffusion as described in Quintero, I., Lartillot, N., & Morlon, H. (2024). \"Imbalanced speciation pulses sustain the radiation of mammals\". Science, 384, 1007-1012. https://doi.org/10.1126/science.adj2793\n\"Trait and Range Interspecific Biogeographic Evolution\" (TRIBE): implements a joint model of trait evolution and biogeographic history as described in Quintero, I., & Landis, M. J. (2020). Interdependent phenotypic and biogeographic evolution driven by biotic interactions. Systematic biology, 69(4), 739-755. https://doi.org/10.1093/sysbio/syz082\n\"Environmental and State dependent Speciation and Extinction\" (ESSE): implements a joint geographic and environmental model of diversification as described in Quintero, I., Landis, M. J., Jetz, W., & Morlon, H. (2022). The build-up of the present-day tropical diversity of tetrapods. Proceedings of the National Academy of Sciences, 2023. 120 (20) e2220672120. https://doi.org/10.1073/pnas.2220672120","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/installation.md\",\n    \"man/insane.md\",\n    \"man/tribe.md\",\n    \"man/esse.md\",\n]\nDepth = 3","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contact Me","category":"page"},{"location":"man/insane/#INSANE","page":"INSANE","title":"INSANE","text":"","category":"section"},{"location":"man/insane/#Insane-Bayesian-data-augmentation","page":"INSANE","title":"Insane Bayesian data augmentation","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"INSANE uses Bayesian data augmentation (DA) to perform inference on a number of evolutionary models on phylogenetic trees. As such, performing inference will output posterior samples for the governing parameters as well as complete or data augmented trees, that is, trees that include probable configurations of unobserved variables such as the lineages that went extinct in the past or the underlying (latent) speciation rate. ","category":"page"},{"location":"man/insane/#References","page":"INSANE","title":"References","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Birth-Death Diffusion (BDD): Quintero, I., Lartillot, N., Morlon, H. (2024). Imbalanced speciation pulses sustain the radiation of mammals. Science, 384: 1007-1012. link","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Diffused Brownian motion (DBM): Quintero, I. (in press). \"The diffused evolutionary dynamics of morphological novelty\". Proceedings of the National Academy of Sciences.","category":"page"},{"location":"man/insane/#Insane-tree-and-model-input/output","page":"INSANE","title":"Insane tree and model input/output","text":"","category":"section"},{"location":"man/insane/#Insane-trees","page":"INSANE","title":"Insane trees","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"INSANE uses different types of trees, but all are recursive structures. All trees have at least three fields: ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"d1 which corresponds to the left daughter (either another tree structure or nothing if it is a tip).\nd2 which corresponds to the right daughter (also either another tree structure or nothing if it is a tip).\ne a decimal number specifying the edge length of the tree.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"For all tree output from simulations and inference (all expect labelled trees):","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"fx a Boolean stating if tree is fixed or not. That is, if it corresponds to a sampled (fx = true) or unsampled (fx = false) lineage.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"For all trees that allow for extinction:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"iμ a Boolean stating if tree is extinct (iμ = true) or not (iμ = false).","category":"page"},{"location":"man/insane/#Insane-simple-trees-(sT)","page":"INSANE","title":"Insane simple trees (sT)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sT_label: is a simple labelled tree, and is the one required as input to perform inference. Note that all other model specific tree types can be converted to sT_label by using the latter as a function: tree = sT_label(tree_of_other_type).","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"It has the additional field l for label.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sTpb: is a simple pure-birth tree for the constant pure-birth (Yule) model.\nsTbd: is a simple birth-death tree for the constant birth_death model.","category":"page"},{"location":"man/insane/#Insane-BDD-trees-(iT)","page":"INSANE","title":"Insane BDD trees (iT)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"All iT trees specify to birth-death diffusion trees with different extinction assumptions and all hold the following extra fields:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"dt a decimal specifying the time step of the GBM discretization.\nfdt a decimal specifying the final time step of the GBM discretization.\nlλ an array specifying the Brownian motion evolution of log-speciation rates.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"And have the following concrete types:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"iTpb, iTce and iTct: are BDD trees with no-extinction (pure-birth), constant extinction and constant turnover, respectively.\niTbd: is the full BDD tree.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"It has the additional field lμ:  an array specifying the Brownian motion evolution of log-extinction rates.","category":"page"},{"location":"man/insane/#Insane-DBM-trees-(sTxs)","page":"INSANE","title":"Insane DBM trees (sTxs)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"dt a decimal specifying the time step of the GBM discretization.\nfdt a decimal specifying the final time step of the GBM discretization.\nxv an array specifying the Brownian motion evolution of traits.\nlσ2 an array specifying the Geometric Brownian motion evolution of rates.","category":"page"},{"location":"man/insane/#Reading-and-saving-newick-trees","page":"INSANE","title":"Reading and saving newick trees","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Tapestree can read files in the simple newick format using the read_newick function:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"tree = read_newick(joinpath(dirname(pathof(Tapestree)), \"..\", \"data\", \"tree_50.tre\"))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Note that the tree has type sT_label, which stands for simple labelled tree. You can check this using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"typeof(tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Similarly, it can also write trees using write_newick","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"write_newick(tree, \"<directory>\")","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Note that only *_label trees (e.g., sT_label) have labels. So if you want to save a DA tree with the original tip labels plus new names to the data augmented trees, you first will have to create a labelled tree from the DA_tree and the loaded labelled tree and then save it:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"write_newick(sT_label(DA_tree, tree), \"<directory>\")","category":"page"},{"location":"man/insane/#Reading-and-saving-model-output","page":"INSANE","title":"Reading and saving model output","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"All models can return and/or save the output by writing directly to a file on the fly and within the Julia session when the model finishes. There are two outputs:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"The governing parameters trace, which is saved as a .log file and returned as the first object once the algorithm finished. These can be conveniently read in the Tracer software (https://github.com/beast-dev/tracer/releases/tag/v1.7.2)[https://github.com/beast-dev/tracer/releases/tag/v1.7.2].\nThe DA trees as a tree vector which are saved as a .txt file (of the same name as the .log) and returned as the second object once the algorithm finished. ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"The DA trees written in the insane-specific .txt file can be read using the iread() function, which only needs the specific file directory as input, but also accepts an optional (keyword) argument ix that indicates the specific tree iterations to read, as an OrdinalRange object. For instance, to read only the first 50 trees, one can use iread(\"<directory to txt>\", ix = 1:50. To read only the trees every 10 iterations from the 100 to 400 sampled, one can use ix = 100:10:400, and so on. This can be helpful to avoid high computation costs of reading very large files.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"You can save any individual or vector of insane trees using the iwrite() function: iwrite(trees, \"<directory>\"), which can be read by Tapestree. For portability, you can also save the DA trees as nexus files where nodes have been annotated with the vector of rates using write_nexus(trees, tree, \"<directory>\"), where trees is the tree vector and tree is the original labelled tree (i.e., the one you used as input into an insane model).","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"read_newick\nwrite_newick\niread\niwrite\nwrite_nexus","category":"page"},{"location":"man/insane/#Tapestree.INSANE.read_newick","page":"INSANE","title":"Tapestree.INSANE.read_newick","text":"read_newick(in_file::String; ix::OrdinalRange{Int64,Int64} = 0:0)\n\nReads a newick tree into sT from in_file at lines ix.\n\n\n\n\n\nread_newick(in_file::String,\n            fossil ::Bool;\n            ix     ::OrdinalRange{Int64,Int64} = 0:0,\n            ne     ::Float64                   = accer)\n\nReads a newick tree into sTf from in_file at lines ix.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.write_newick","page":"INSANE","title":"Tapestree.INSANE.write_newick","text":"write_newick(tree::T, ofile::String)\n\nWrites an iTree as a newick tree to ofile.\n\n\n\n\n\nwrite_newick(treev::Vector{T}, ofile::String)\n\nWrites an iTree as a newick tree to ofile.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.iread","page":"INSANE","title":"Tapestree.INSANE.iread","text":"iread(file::String; ix::OrdinalRange{Int64,Int64} = 0:0)\n\nRead a tree file exported by insane in file and with optional OrdinalRange specifying which trees to sample.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.iwrite","page":"INSANE","title":"Tapestree.INSANE.iwrite","text":"iwrite(tree::T, ofile::String) where {T <: iTree}\n\nWrite iTree to file.\n\n\n\n\n\niwrite(tree::Vector{T}, ofile::String) where {T <: iTree}\n\nWrite a vector of trees.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.write_nexus","page":"INSANE","title":"Tapestree.INSANE.write_nexus","text":"write_nexus(tree::T, reftree::sT_label, ofile::String) where {T <: iTree}\n\nWrites an iTree as a extensive nexus tree to ofile.\n\n\n\n\n\nwrite_nexus(treev::Vector{T}, reftree::sT_label, ofile::String) where {T <: iTree}\n\nWrites an iTree as a extensive nexus tree to ofile.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Insane-models","page":"INSANE","title":"Insane models","text":"","category":"section"},{"location":"man/insane/#Tree-input","page":"INSANE","title":"Tree input","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"All inference functions require a phylogenetic tree of type sT_label, that is, a simple labelled tree. This is the default object type when using the read_newick function. However, when using simulations from models or iread, the resulting type is specific to the model (for computational efficiency). One can easily create a tree of type sT_label from any other tree by using sT_label(tree). The output can then be used to perform inference.","category":"page"},{"location":"man/insane/#Common-(keyword)-arguments-across-all-insane-inference-models","page":"INSANE","title":"Common (keyword) arguments across all insane inference models","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"nburn: specifies the number of iterations to discard as burn-in.\nniter: specifies the number of MCMC iterations. \nnthin: specifies the iteration frequency at which to save the parameters in the julia session (i.e.,nthin = 2 specifies saving every 2 iterations), \nnflush: specifies the frequency at which to save to file. \nofile: specifies the directory where the results will be written. \ntρ: controls the sampling fraction and receives a Dictionary as input, with a String key pointing to a Float64 number (i.e., Dict{String, Float64}). If the dictionary is of length 1 with an empty string, then the insane sets this as a the global sampling fraction. For example, to set a sampling fraction of 0.6, one show input tρ = Dict(\"\" => 0.6). Most times, however, sampling fraction is not uniform across the tree, but rather some part so the tree is more heavily sampled than others, to accommodate these variability, you can input a dictionary of the same length as the number of tips in the tree, where the dictionary key string is the tip label pointing to the specific sampling fraction value. For example, for two tips, named tip_1 and tip_2, one could input tρ = Dict(\"tip_1\" => 0.5, \"tip_2\" => 0.3). Make sure to specify all tips when assigning different sampling fractions across the tips, even ones with 1.0. \nprints: specifies the number of seconds to refresh the progress meter.\nsurvival: For those modesl with extinction, true or false if to condition the likelihood on survival.","category":"page"},{"location":"man/insane/#Constant-rate-models","page":"INSANE","title":"Constant rate models","text":"","category":"section"},{"location":"man/insane/#Constant-pure-birth-(Yule)-process-(CPB)","page":"INSANE","title":"Constant pure-birth (Yule) process (CPB)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"The simplest diversification model assumes no extinction and a constant speciation rate lambda, also known as, the pure-birth or Yule model.","category":"page"},{"location":"man/insane/#Simulations","page":"INSANE","title":"Simulations","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To simulate a pure-birth tree one can use sim_cpb. For instance, for a period of 10 time units and a speciation rate of lambda = 05:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"tr = sim_cpb(10.0, 0.5)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_cpb","category":"page"},{"location":"man/insane/#Tapestree.INSANE.sim_cpb","page":"INSANE","title":"Tapestree.INSANE.sim_cpb","text":"sim_cpb(t::Float64, λ::Float64)\n\nSimulate a constant pure-birth iTree of height t with speciation rate λ.\n\n\n\n\n\nsim_cpb(t::Float64, λ::Float64, na::Int64)\n\nSimulate a constant pure-birth iTree of height t with speciation rate λ.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Inference","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To perform inference on a tree (of type sT_label), we can use the insane_cpb function (cpb = constant pure-birth).","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_cpb(tree,\n                   nburn  = 500,\n                   niter  = 1_000,\n                   nthin  = 2,\n                   nflush = nthin,\n                   ofile  = \"<directory>\")","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Note that for this specific CPB model, where the sampling fraction, rho, is 1, there are no unobserved components since we assume no extinction and that all species have been sampled. In this case, all the trees in the tree vector will be exactly the same.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"In the following example, we now specify a global sampling fraction of 0.8.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_cpb(tree,\n                   nburn  = 500,\n                   niter  = 1_000,\n                   nthin  = 2,\n                   nflush = nthin,\n                   ofile  = \"<directory>\",\n                   tρ     = Dict(\"\" => 0.8))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"This time, the DA trees are different from one another since they have data augmented lineages that represent that proportion of species not included in the tree. The position change from tree to tree because we are integrating over their unknown placement. You can check this by plotting the trees (check Insane plots). For instance, to plot the first tree in the vector:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(tv[1])","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Finally, it is important to note that we use Gibbs sampling across most parameter updates in INSANE. So, the prior for speciation in the CPB is a Gamma prior, and its parameters can be specified with argument λ_prior, The default is λ_prior = (1.0, 1.0).","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"insane_cpb","category":"page"},{"location":"man/insane/#Tapestree.INSANE.insane_cpb","page":"INSANE","title":"Tapestree.INSANE.insane_cpb","text":"insane_cpb(tree    ::sT_label;\n           λ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n           niter   ::Int64                 = 1_000,\n           nthin   ::Int64                 = 10,\n           nburn   ::Int64                 = 200,\n           nflush  ::Int64                 = nthin,\n           ofile   ::String                = string(homedir(), \"/cpb\"),\n           λi      ::Float64               = NaN,\n           pupdp   ::NTuple{2,Float64}     = (0.2, 0.2),\n           prints  ::Int64                 = 5,\n           tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for constant pure-birth.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Constant-birth-death-process-(CBD)","page":"INSANE","title":"Constant birth-death process (CBD)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We now consider that species have an instantaneous constant rate of extinction, mu, besides the constant rate of speciation lambda.","category":"page"},{"location":"man/insane/#Simulations-2","page":"INSANE","title":"Simulations","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To simulate under the CBD model, say, for a period of 10, with speciation rate of 05, and extinction rate of 03, a one can use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"tr = sim_cbd(10.0, 0.5, 0.3)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_cbd","category":"page"},{"location":"man/insane/#Tapestree.INSANE.sim_cbd","page":"INSANE","title":"Tapestree.INSANE.sim_cbd","text":"sim_cbd(t::Float64, λ::Float64, μ::Float64)\n\nSimulate a constant birth-death iTree of height t with speciation rate λ and extinction rate μ.\n\n\n\n\n\nsim_cbd(t ::Float64,\n        λ ::Float64,\n        μ ::Float64,\n        na::Int64)\n\nSimulate a constant birth-death iTree of height t with speciation rate λ and extinction rate μ.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Inference-2","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To perform  inference on the CBD model, we can use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_cbd(tree,\n                   nburn    = 1_000,\n                   niter    = 50_000,\n                   nthin    = 50, \n                   ofile    = \"<directory>\",\n                   λ_prior  = (1.0, 1.0),\n                   μ_prior  = (1.0, 1.0),\n                   survival = true,\n                   tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where we now have a Gamma prior for the extinction mu, and we can also specify if we want to condition on survival of the process with survival.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"insane_cbd","category":"page"},{"location":"man/insane/#Tapestree.INSANE.insane_cbd","page":"INSANE","title":"Tapestree.INSANE.insane_cbd","text":"insane_cbd(tree    ::sT_label;\n           λ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n           μ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n           niter   ::Int64                 = 1_000,\n           nthin   ::Int64                 = 10,\n           nburn   ::Int64                 = 200,\n           nflush  ::Int64                 = nthin,\n           ofile   ::String                = string(homedir(), \"/cbd\"),\n           ϵi      ::Float64               = 0.4,\n           λi      ::Float64               = NaN,\n           μi      ::Float64               = NaN,\n           pupdp   ::NTuple{3,Float64}     = (0.2,0.2,0.2),\n           prints  ::Int64                 = 5,\n           survival::Bool                  = true,\n           mxthf   ::Float64               = Inf,\n           tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for constant birth-death.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Birth-death-diffusion-(BDD)-processes","page":"INSANE","title":"Birth-death diffusion (BDD) processes","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"These models all assume that the per-lineage instantaneous speciation rates lambda(t) follow a Geometric Brownian motion (GBM), such that","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"d(textln(lambda(t)) = alpha dt + sigma_lambda d W(t)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where alpha is the drift, sigma_lambda is the diffusion for speciation, and W(t) is the Wiener process, and holding different assumptions on extinction.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"The likelihood is approximated using the Euler method to solve Stochastic Differential Equations, and require to set a minimum time step for the discretization of the augmented diffusion paths. In INSANE δt (by default 10^-3) sets the time step to perform the Euler approximation, and denotes the proportion with respect to the tree height (the duration of the tree), so the time step will be δt = th times 10^-3, where th is the tree height.","category":"page"},{"location":"man/insane/#Pure-birth-diffusion-(\\mu(t)-0)","page":"INSANE","title":"Pure birth diffusion (mu(t) = 0)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"In the simplest BDD model, the pure-birth diffusion, we assume there is no extinction, that is mu(t) = 0.","category":"page"},{"location":"man/insane/#Simulations-3","page":"INSANE","title":"Simulations","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"For all the BDD models, we have the possibility to simulate conditioned on total simulation time or the number of species.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To simulate conditioned on some number of species, say, 20, with starting speciation rate of lambda_0 = 10, drift of alpha = 0 and diffusion of sigma_lambda = 01, we can use:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":" sim_gbmpb(20, λ0 = 1.0, α = 0.0, σλ = 0.1)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Similarly, to simulate conditioned on time, say, 10 time units, with the same parameters, we can use:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":" sim_gbmpb(10.0, λ0 = 1.0, α = 0.0, σλ = 0.1)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Other options are available, such as δt which controls the time step of the simulation, which uses the Euler approximation. Similarly, init can be :crown or :stem to simulate starting with 1 or 2 lineages. ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Note then that the simulations conditioned on time must input a Float64 as first (and mandatory) argument while those conditioned on number of species must rater input a Int64.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_gbmpb","category":"page"},{"location":"man/insane/#Tapestree.INSANE.sim_gbmpb","page":"INSANE","title":"Tapestree.INSANE.sim_gbmpb","text":"sim_gbmpb(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          δt      ::Float64 = 1e-3,\n          init    ::Symbol  = :stem,\n          nstar   ::Int64   = n + 2,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true,\n          maxt    ::Float64 = δt*1e7)\n\nSimulate iTpb according to a pure-birth geometric Brownian motion.\n\n\n\n\n\nsim_gbmpb(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTpb according to a pure-birth geometric Brownian motion conditional in stopping at time t.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Inference-3","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To perform inference under this model we can use:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_gbmpb(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.05, 0.5),\n                     tρ    = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Here, the prior for the drift α_prior is a Normal distribution, with the first element representing the mean and the second the standard deviation, and the prior for the diffusion of speciation is an Inverse Gamma. ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"insane_gbmpb","category":"page"},{"location":"man/insane/#Tapestree.INSANE.insane_gbmpb","page":"INSANE","title":"Tapestree.INSANE.insane_gbmpb","text":"insane_gbmpb(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 1.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ipb\"),\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.1,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.01, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             stn     ::Float64               = 0.5,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for pbd.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Birth-death-diffusion-process-with-constant-extinction-(\\mu(t)-\\mu)","page":"INSANE","title":"Birth-death diffusion process with constant extinction (mu(t) = mu)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Here we assume that there is extinction, but that is constant across lineages and time.","category":"page"},{"location":"man/insane/#Simulations-4","page":"INSANE","title":"Simulations","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"As with the pure-birth diffusion, we can simulate conditioned on reaching some number of lineages or some time. Now, however, we need to specify the extinction rate as well, for instance to generate a tree with 20 species and some parameter values:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":" sim_gbmce(20, λ0 = 1.0, α = 0.0, σλ = 0.1, μ = 0.7)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_gbmce","category":"page"},{"location":"man/insane/#Tapestree.INSANE.sim_gbmce","page":"INSANE","title":"Tapestree.INSANE.sim_gbmce","text":"sim_gbmce(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          μ       ::Float64 = 0.0,\n          δt      ::Float64 = 1e-3,\n          init    ::Symbol  = :stem,\n          nstar   ::Int64   = 2*n,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true,\n          maxt    ::Float64 = δt*1e7)\n\nSimulate iTce according to a geometric Brownian motion for birth rates and constant extinction.\n\n\n\n\n\nsim_gbmce(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          μ   ::Float64 = 0.2,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTce according to a geometric Brownian motion for birth rates and constant extinction.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Inference-4","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To perform inference we can use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_gbmce(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.05, 0.5),\n                     μ_prior  = (1.0, 1.0),\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where we now specify the Gamma prior μ_prior for the extinction.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"insane_gbmce","category":"page"},{"location":"man/insane/#Tapestree.INSANE.insane_gbmce","page":"INSANE","title":"Tapestree.INSANE.insane_gbmce","text":"insane_gbmce(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 10.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             μ_prior ::NTuple{2,Float64}     = (1.0, 1.0),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ice\"),\n             λi      ::Float64               = NaN,\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.01,\n             μi      ::Float64               = NaN,\n             ϵi      ::Float64               = 0.2,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.01, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = 0.1,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for gbm-ce.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Birth-death-diffusion-process-with-constant-turnover-(\\mu(t)-\\epsilon-\\lambda(t))","page":"INSANE","title":"Birth-death diffusion process with constant turnover (mu(t) = epsilon lambda(t))","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"One can also assume that turnover, epsilon, that is, the ration of extinction over speciation (i.e., fracmulambda), is constant.","category":"page"},{"location":"man/insane/#Simulations-5","page":"INSANE","title":"Simulations","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"As with the other BDD models, we can simulate both conditioned on the number of species or in time. For instance, here we condition on time with a turnover rate of 04.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":" sim_gbmct(10.0, λ0 = 1.0, α = 0.0, σλ = 0.1, ϵ = 0.4)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_gbmct","category":"page"},{"location":"man/insane/#Tapestree.INSANE.sim_gbmct","page":"INSANE","title":"Tapestree.INSANE.sim_gbmct","text":"sim_gbmct(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          ϵ       ::Float64 = 0.0,\n          δt      ::Float64 = 1e-3,\n          init    ::Symbol  = :stem,\n          nstar   ::Int64   = 2*n,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true,\n          maxt    ::Float64 = δt*1e7)\n\nSimulate iTct according to a geometric Brownian motion for birth rates and constant turnover.\n\n\n\n\n\nsim_gbmct(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          ϵ   ::Float64 = 0.2,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTct according to a geometric Brownian motion for birth rates and constant turnover.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Inference-5","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Performing inference can then be done using:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_gbmct(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.05, 0.5),\n                     ϵ_prior  = (0.0, 100.0),\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where we now specify a Uniform prior ϵ_prior for the turnover. Also, INSANE resorts to simple MH updates for epsilon, so an increased burnin is recommended. ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"insane_gbmct","category":"page"},{"location":"man/insane/#Tapestree.INSANE.insane_gbmct","page":"INSANE","title":"Tapestree.INSANE.insane_gbmct","text":"insane_gbmct(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 1.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             ϵ_prior ::NTuple{2,Float64}     = (0.0, 10.0),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ict\"),\n             tune_int::Int64                 = 100,\n             αi      ::Float64               = 0.0,\n             λi      ::Float64               = NaN,\n             σλi     ::Float64               = 0.01,\n             ϵi      ::Float64               = 0.2,\n             ϵtni    ::Float64               = 0.1,\n             obj_ar  ::Float64               = 0.234,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.01, 0.1, 0.2),\n             ntry    ::Int64                 = 2,\n             nlim    ::Int64                 = 500,\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = Inf,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for GBM birth-death.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Birth-death-diffusion-process","page":"INSANE","title":"Birth-death diffusion process","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Finally, we arrive at the most complex model, where extinction also follows a GBM, that is,","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"d(textln(mu(t)) = sigma_mu d W(t)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where sigma_mu is the diffusion for extinction.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Note that this is unidentifiable, unless we specify strong priors on the extinction diffusion coefficient sigma_mu, and still do not do well in recovering simulated values, at least for small trees.","category":"page"},{"location":"man/insane/#Simulations-6","page":"INSANE","title":"Simulations","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Again, one can specify a time or a number of lineages to simulate under the BDD. For example, for 50 species","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":" sim_gbmbd(50, λ0 = 1.0, μ0 = 1.0, α = 0.0, σλ = 0.1, σμ = 0.1)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_gbmbd","category":"page"},{"location":"man/insane/#Tapestree.INSANE.sim_gbmbd","page":"INSANE","title":"Tapestree.INSANE.sim_gbmbd","text":"sim_gbmbd(n       ::Int64;\n          λ0      ::Float64 = 1.0,\n          μ0      ::Float64 = 0.1,\n          α       ::Float64 = 0.0,\n          σλ      ::Float64 = 0.1,\n          σμ      ::Float64 = 0.1,\n          init    ::Symbol  = :stem,\n          δt      ::Float64 = 1e-3,\n          nstar   ::Int64   = 2*n,\n          p       ::Float64 = 5.0,\n          warnings::Bool    = true)\n\nSimulate iTbd according to geometric Brownian motions for birth and death rates.\n\n\n\n\n\nsim_gbmbd(t   ::Float64;\n          λ0  ::Float64 = 1.0,\n          μ0  ::Float64 = 0.2,\n          α   ::Float64 = 0.0,\n          σλ  ::Float64 = 0.1,\n          σμ  ::Float64 = 0.1,\n          δt  ::Float64 = 1e-3,\n          nlim::Int64   = 10_000,\n          init::Symbol  = :crown)\n\nSimulate iTbd according to geometric Brownian motions for birth and death rates.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Inference-6","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"One can perform inference using:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_gbmbd(tree,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     λ0_prior = (0.05, 148.41),\n                     μ0_prior = (0.05, 148.41),\n                     α_prior  = (0.0, 10.0),\n                     σλ_prior = (0.5, 0.05),\n                     σμ_prior = (3.0, 0.5),\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where we have log-normal priors on the initial (root) values for lambda_0 and mu_0, and Inverse Gamma prior for sigma. Usually, an informative prior such as σμ_prior = (3.0, 0.5) or more is needed.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"insane_gbmbd","category":"page"},{"location":"man/insane/#Tapestree.INSANE.insane_gbmbd","page":"INSANE","title":"Tapestree.INSANE.insane_gbmbd","text":"insane_gbmbd(tree    ::sT_label;\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             μ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 10.0),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             σμ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ibd\"),\n             ϵi      ::Float64               = 0.2,\n             λi      ::Float64               = NaN,\n             μi      ::Float64               = NaN,\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.01,\n             σμi     ::Float64               = 0.01,\n             pupdp   ::NTuple{5,Float64}     = (0.01, 0.01, 0.0001, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = 0.1,\n             prints  ::Int64                 = 5,\n             stnλ    ::Float64               = 0.5,\n             stnμ    ::Float64               = 0.5,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for bdd.\n\n\n\n\n\ninsane_gbmbd(tree    ::sT_label,\n             tv      ::Vector{Vector{Float64}},\n             ev      ::Vector{Vector{Float64}};\n             λ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             μ0_prior::NTuple{2,Float64}     = (0.05, 148.41),\n             α_prior ::NTuple{2,Float64}     = (0.0, 0.5),\n             σλ_prior::NTuple{2,Float64}     = (3.0, 0.5),\n             σμ_prior::NTuple{2,Float64}     = (5.0, 0.5),\n             niter   ::Int64                 = 1_000,\n             nthin   ::Int64                 = 10,\n             nburn   ::Int64                 = 200,\n             nflush  ::Int64                 = nthin,\n             ofile   ::String                = string(homedir(), \"/ibd_efx\"),\n             ϵi      ::Float64               = 0.2,\n             λi      ::Float64               = NaN,\n             αi      ::Float64               = 0.0,\n             σλi     ::Float64               = 0.01,\n             σμi     ::Float64               = 0.01,\n             pupdp   ::NTuple{4,Float64}     = (0.01, 0.01, 0.1, 0.2),\n             δt      ::Float64               = 1e-3,\n             prints  ::Int64                 = 5,\n             survival::Bool                  = true,\n             mxthf   ::Float64               = Inf,\n             tρ      ::Dict{String, Float64} = Dict(\"\" => 1.0))\n\nRun insane for gbm-bd with fixed extinction.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Birth-death-diffusion-process-with-informed-extinction","page":"INSANE","title":"Birth-death diffusion process with informed extinction","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"One can also define a branch-specific fixed extinction function and make inference on the GBM speciation. For example, in Quintero et al. (2024) Science, we estimated extinction rates based on fossil occurrences and then used this as input.","category":"page"},{"location":"man/insane/#Inference-7","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To make inference under this model, we need two vectors where each element links to a given branch in the reconstructed tree, in the same order as the phylogenetic tree. Each element of these vectors are themselves a vector of type Float64, and correspond to the time at which extinction is recovered in time backward order (e.g., [1.1, 1.0, ..., 0.1, 0.08, 0.0]) and to the extinction at those times. INSANE uses a linear approximation function between the input sampled points.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To make inference under this model, we now input these vectors. Lets call them time_vector (of type Vector{Vector{Float64}}) and extinction_vector (also of type Vector{Vector{Float64}}), then:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, tv = insane_gbmbd(tree,\n                     time_vector,\n                     extinction_vector,\n                     nburn    = 1_000,\n                     niter    = 50_000,\n                     nthin    = 50, \n                     ofile    = \"<directory>\",\n                     tρ       = Dict(\"\" => 1.0))","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"The only thing one has to make sure is that the order of time_vector and extinction_vector correspond to the order of the branches in tree, which can be a bit involved. However, this can be achieved by understanding that the trees are recursive and are ordered either by left or right branch, and using some of the tree utility functions. ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"For example, one can use the subclade function, to extract a subclade given a set of tip labels. One can also use the make_idf function, which splits the tree into a vector of branches in the same order that INSANE will process the tree. This way one can see the ordering of branches, and then order the time_vector and the extinction_vector in the same order.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"If only one extinction function is used for all the tree, then one has to only create a vector of the time and extinction vector of equal size as the number of branches.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To estimate the number of branches in your empirical tree (saved in <...tree directory...>), we can do:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"# read tree\ntre = read_newick(\"<...tree directory...>\")\n\n## make extinction function vectors for each branch\n# set a dummy smapling fraction (you can set the real one afterwards! - this is just to estimate the number of branches)\ntρ  = Dict(li => 1.0 for li in tiplabels(tre))\nidf = make_idf(tre, tρ, Inf)\n\n# number of branches\nnb = length(idf)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"If we have a global curve with extinction [0.06, 0.02, 0.05] at times [0.5, 0.3, 0.1], then we would have to create the following input objects for time_vector and extinction_vector:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"extinction_vector = fill([0.06, 0.02, 0.05], nb)\ntime_vector = fill([0.5, 0.3, 0.1], nb)","category":"page"},{"location":"man/insane/#Diffused-Brownian-motion-process-(DBM)","page":"INSANE","title":"Diffused Brownian motion process (DBM)","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"This is a model of trait evolution where an univariate trait x(t) evolves under a diffused Brownian motion with an underlying evolutionary rate sigma^2(t) that is also itself evolving separately according to Geometric Brownian motion.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"we arrive at the most complex model, where extinction also follows a GBM, that is,","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"dx(t) = alpha_x dt + sigma(t) d W(t) \nd(textln(sigma^2(t)) = alpha_sigma dt + gamma d W(t)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where alpha_x is the trait drift (general trait tendency to increase or decrease), alpha_sigma is the drift in evolutionary rates, and gamma represents the heterogeneity in evolutionary rates.","category":"page"},{"location":"man/insane/#Simulations-7","page":"INSANE","title":"Simulations","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"In the DBM, we are not modeling the realization of the tree, but rather a process that evolved along the tree. Thus, to simulate, we need a tree to be used as template so that we can simulate on top. So if we have a tree object of type sT_label or sTf_label, we can simulate a trait with a starting trait value of x0 (x(t = 0)), with drift αx (alpha_x), undergoing a starting rate of σ20 (sigma^2(t = 0)) with drift ασ (alpha_sigma), with a maximal discretization time step of δt:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_dbm(tree, x0 = 0.0, αx = 0.0, σ20 = 0.1, ασ = 0.0, γ = 0.1, δt = 1e-3)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"which returns a tree of type sTxs, holding the simulation.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"It might also be useful to return a Dictionary with the final trait values at each sampled species. For this, use the same function, in the same argument order but not using named arguments. For instance, the same simulation above, but returning both a sTxs tree named tr and a dictionary of species values named xd:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"tr, xd = sim_dbm(tree, 0.0, 0.0, 0.1, 0.0, 0.1, 1e-3)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can plot the resulting tree using Tapestree's plot recipes (Insane plots). For example to plot the trait evolution colored by the logarithmic rates:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(xv, tr, zf = lσ2)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sim_dbm","category":"page"},{"location":"man/insane/#Tapestree.INSANE.sim_dbm","page":"INSANE","title":"Tapestree.INSANE.sim_dbm","text":"sim_dbm(tree::iTree; \n        x0  ::Float64 = 0.0,\n        αx  ::Float64 = 0.0,\n        σ20 ::Float64 = 0.1,\n        ασ  ::Float64 = 0.0,\n        γ   ::Float64 = 0.1,\n        δt  ::Float64 = 1e-3)\n\nSimulate a diffused Brownian motion given starting values.\n\n\n\n\n\nsim_dbm(tree::Tlabel, \n        x0  ::Float64,\n        αx  ::Float64,\n        σ20 ::Float64,\n        ασ  ::Float64,\n        γ   ::Float64,\n        δt  ::Float64)\n\nSimulate a diffused Brownian motion given starting values.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Inference-8","page":"INSANE","title":"Inference","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"For a given sT_label or sTf_label type tree object and a Dictionary xav with a String key pointing to a Float64 number (i.e., Dict{String, Float64}), where matching tip labels point to the trait value. If tip labels are not included in the dictionary, the trait value is assumed missing. ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, td = insane_dbm(tree, xav,\n                   γ_prior  = (0.05, 0.05),\n                   αx_prior = (0.0, 10.0),\n                   ασ_prior = (0.0, 10.0),\n                   nburn    = 10_000,\n                   niter    = 100_000,\n                   nthin    = 1_000,\n                   nthin    = 1_000,\n                   ofile    = \"<...directory...>\",\n                   δt       = 1e-3)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Finally, error or uncertainty around trait values can be included (assuming Normal variance) by setting another Dictionary, called say xsv, (also Dict{String, Float64}), where tip values point to the variance around trait values. Again, if tip labels are not included in this dictionary, it is assumed that there is no error around tip values. Then you specify this dictionary on the argument xs:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"r, td = insane_dbm(tree, xav, \n                   xs       = xsv,\n                   γ_prior  = (0.05, 0.05),\n                   αx_prior = (0.0, 10.0),\n                   ασ_prior = (0.0, 10.0),\n                   nburn    = 10_000,\n                   niter    = 100_000,\n                   nthin    = 1_000,\n                   nthin    = 1_000,\n                   ofile    = \"<...directory...>\",\n                   δt       = 1e-3)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"insane_dbm","category":"page"},{"location":"man/insane/#Tapestree.INSANE.insane_dbm","page":"INSANE","title":"Tapestree.INSANE.insane_dbm","text":"insane_dbm(tree     ::Tlabel,\n           xa       ::Dict{String, Float64};\n           xs       ::Dict{String, Float64} = Dict{String,Float64}(),\n           αx_prior ::NTuple{2,Float64} = (0.0, 10.0),\n           ασ_prior ::NTuple{2,Float64} = (0.0, 10.0),\n           γ_prior  ::NTuple{2,Float64} = (0.05, 0.05),\n           niter    ::Int64             = 1_000,\n           nthin    ::Int64             = 10,\n           nburn    ::Int64             = 200,\n           nflush   ::Int64             = nthin,\n           ofile    ::String            = string(homedir(), \"/dbm\"),\n           αi       ::Float64           = 0.0,\n           γi       ::Float64           = 1e-3,\n           pupdp    ::NTuple{4,Float64} = (0.1, 0.1, 0.05, 0.9),\n           δt       ::Float64           = 1e-3,\n           stn      ::Float64           = 0.1,\n           mxthf    ::Float64           = Inf,\n           prints   ::Int64             = 5)\n\nRun diffused Brownian motion trait evolution model.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Insane-tree-data-access-and-processing-functions","page":"INSANE","title":"Insane tree data access and processing functions","text":"","category":"section"},{"location":"man/insane/#Simple-tree-information","page":"INSANE","title":"Simple tree information","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Simple information about the tree, such as the number tips, the number of extinct tips, the tree height (duration of the tree) and the tree length (sum of all branch lengths) can be performed using, respectively:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"ntips(tree)\nntipsextinct(tree)\ntreeheight(tree)\ntreelength(tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Julia makes it simple to look at statistics across a vector of trees. For example, using the package Statistics, we can estimate the average number of extinct species on tree vector tv by simply:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"using Statistics \n\nmean(ntipsextinct, tv)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"See the documentation of mean for more details, but basically, mean, and many other functions in Julia allow to perform a undefined function on each element before calculating the mean. In this case, we are estimating the number of extinct tips in each tree in tv, and then averaging over them.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"For labelled trees, one can extract the tip labels using tiplabels. Moreover we can create subclades based on a vector of tips, where the subclade will be the minimum tree that has all the tips. For example, for a vector tip_vector holding Strings that correspond to the tip labels in the tree of type sT_label, we can use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"subclade(tree, tip_vector)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"However, most time we want to extract subclades of other types of trees. Since these do not hold label information but should be ordered in the same order as the sT_label tree, one has to use both. Note, if you change the order of either the sT_label tree or the single of vector of trees of other types, this will not work. Thus, if we want a the subclades that have the tips in tip_vector, we can use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"subclade(tv, tree, tip_vector, true)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where the last argument states if returning the stem or crown tree.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"One can also estimate the Lineage Through Time (LTT), or, for a data augmented tree (or a vector of trees), the Diversity Through Time (DTT) using ","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"ltt(tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To be clear, the LTT is usually used to describe the accumulation of reconstructed lineages (those that have been sampled) while DTT is used to describe estimated diversity (sampled and unsampled lineages). Thus, the result is either LTT or DTT simply depending on the tree you use as input.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can also estimate the ltt for a tree vector tv using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"ltt(tv)","category":"page"},{"location":"man/insane/#BDD-information","page":"INSANE","title":"BDD information","text":"","category":"section"},{"location":"man/insane/#Estimating-posterior-average-rates-along-the-tree","page":"INSANE","title":"Estimating posterior average rates along the tree","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Of particular interest is the estimation of posterior average rates along the reconstructed tree. Note that since the data augmented (unsampled) lineages change between different iterations of the algorithm, we obtain lineage-specific instantaneous rate distributions only for the reconstructed (observed) tree (the tree we used as input). Consequently, we first need to remove the data augmented lineages from all the trees in the posterior tree vector:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"tv0 = remove_unsampled(tv)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can then estimate the average tree using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"tm = imean(tv0)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can also estimate any quantile tree, for instance, for the 025 quantile tree:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"t025 = iquantile(tv0, 0.25)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Clearly, these resulting trees can then be further scrutinized as with any other tree in INSANE.","category":"page"},{"location":"man/insane/#Other-data-access-and-averaging-functions","page":"INSANE","title":"Other data access and averaging functions","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"If one wants to obtain the range (i.e., extrema) of the output of function f on tree, for example, the maximum and minimum speciation rates:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"irange(tree, b)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"If one wants to sample, recursively, some function at regular intervals along a tree, one can use sample. For example if we want to sample speciation rates every 01 time units, we can use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"sample(tv, b, 0.1)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Note that here we are sampling along each branch of the tree in recursive order, not sampling across lineages through time. If we would like to extract an array across lineages in a given tree of the output of function f, we would use time_rate. For example, if we want the cross-lineage extinction rates of a tree of type iTbd sampled every 05 time units, we would use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"time_rate(tv, d, 0.5)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"which returns a vector of vectors, where each element is a time holding the rates (in this case extinction rates) of all contemporary lineages at that time.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Finally, a convenience wrapper to extract information recursively from a tree is trextract. For example, if we want all branch lengths for a tree, we can use","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"trextract(tree, e)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Below are some functions to obtain data from trees.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"tiplabels\nntips\nntipsalive\nntipsextinct\ntreeheight\ntreelength\nltt\niscrowntree\nirange\ntime_rate\ntrextract\nsubclade\nlλ\nlμ\ne ","category":"page"},{"location":"man/insane/#Tapestree.INSANE.tiplabels","page":"INSANE","title":"Tapestree.INSANE.tiplabels","text":"tiplabels(tree::T) where {T <: Tlabel}\n\nReturns tip labels for sT_label and sTf_label.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.ntips","page":"INSANE","title":"Tapestree.INSANE.ntips","text":"ntips(tree::T) where {T <: iTree}\n\nReturn the number of tip nodes for tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.ntipsalive","page":"INSANE","title":"Tapestree.INSANE.ntipsalive","text":"ntipsalive(tree::T) where {T <: iTree}\n\nReturn the number of alive nodes for tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.ntipsextinct","page":"INSANE","title":"Tapestree.INSANE.ntipsextinct","text":"ntipsextinct(tree::T) where {T <: iTree}\n\nReturn the number of extinct nodes for tree.\n\n\n\n\n\nntipsextinct(Ξ::Vector{T}) where {T <: iTree}\n\nReturn the number of extinct nodes in Ξ.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.treeheight","page":"INSANE","title":"Tapestree.INSANE.treeheight","text":"treeheight(tree::T) where {T <: iTree}\n\nReturn the tree height of tree.\n\n\n\n\n\ntreeheight(tree::T) where {T <: iTf}\n\nReturn the tree height of tree.\n\n\n\n\n\ntreeheight(tree::T, nd::Int64) where {T <: iTree}\n\nReturn the tree height of tree.\n\n\n\n\n\ntreeheight(tree::T, nd::Int64) where {T <: iTf}\n\nReturn the tree height of tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.treelength","page":"INSANE","title":"Tapestree.INSANE.treelength","text":"treelength(tree::T) where {T <: iTree}\n\nReturn the branch length sum of tree.\n\n\n\n\n\ntreelength(tree::T, ets::Vector{Float64})  where {T <: iTf}\n\nReturn the branch length sum of tree at different epochs, initialized at l.\n\n\n\n\n\ntreelength(Ξ::Vector{T}) where {T <: iTree}\n\nReturn the branch length sum of Ξ.\n\n\n\n\n\ntreelength(Ξ  ::Vector{T},\n           ets::Vector{Float64},\n           bst::Vector{Float64},\n           eix::Vector{Int64})  where {T <: iTf}\n\nReturn the branch length sum of tree at different epochs, initialized at l.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.ltt","page":"INSANE","title":"Tapestree.INSANE.ltt","text":"ltt(tree::T) where {T <: iTree}\n\nReturns number of species through time.\n\n\n\n\n\nltt(tree::Vector{T}) where {T <: iTree}\n\nReturns number of species through time for a tree vector.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.iscrowntree","page":"INSANE","title":"Tapestree.INSANE.iscrowntree","text":"iscrowntree(tree::T) where {T <: iTree}\n\nReturn if the tree is a crown tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.irange","page":"INSANE","title":"Tapestree.INSANE.irange","text":"irange(tree::T, f::Function) where {T <: iTree}\n\nReturn the extrema of the output of function f on tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.time_rate","page":"INSANE","title":"Tapestree.INSANE.time_rate","text":"time_rate(tree::T, f::Function, δt::Float64) where {T <: iT}\n\nExtract values from f function at times sampled every δt across the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.trextract","page":"INSANE","title":"Tapestree.INSANE.trextract","text":"trextract(tree::iTree, f::Function)\n\nPerform function f in each recursive tree in tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.subclade","page":"INSANE","title":"Tapestree.INSANE.subclade","text":"subclade(tree::iTree, ix::Int64)\n\nReturn the minimum stem subclade according to recursive position ix.\n\n\n\n\n\nsubclade(trees::Vector{T}, \n              ltree::sT_label, \n              tips ::Vector{String},\n              stem ::Bool) where {T <: iTree}\n\nReturn the minimum subclade that includes tip labels in tips.\n\n\n\n\n\nsubclade(tree::sT_label, tips::Vector{String})\n\nReturn the minimum subclade that includes tip labels in tips.\n\n\n\n\n\nsubclade(tree::iTree, \n         ltree::sT_label, \n         tips ::Vector{String}, \n         stem ::Bool)\n\nReturn the minimum subclade that includes tip labels in tips.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.lλ","page":"INSANE","title":"Tapestree.INSANE.lλ","text":"lλ(tree::T) where {T <: iT}\n\nReturn pendant edge.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.lμ","page":"INSANE","title":"Tapestree.INSANE.lμ","text":"lμ(tree::iTbdU)\n\nReturn pendant edge.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.e","page":"INSANE","title":"Tapestree.INSANE.e","text":"e(id::iB)\n\nReturn initial absolute time.\n\n\n\n\n\ne(tree::T) where {T <: iTree}\n\nReturn edge length.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Insane-tree-manipulation-functions","page":"INSANE","title":"Insane tree manipulation functions","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Two important manipulation functions are, first to be able to remove extinct lineages, which can be performed on a tree or a tree vector using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"remove_extinct(tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Similarly, as shown above, one can remove the unsampled lineages (all the data augmented lineages) on a single or vector of trees using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"remove_unsampled(tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Note that these two are different. First, when performing simulations, the tree is not fixed, which means that if you run remove_unsampled, you will remove the tree. You would have to fix the tree before, which can be done using fixtree!(tree). Also, if sampling fraction is not 1, remove_unsampled will also remove lineages alive that were not sampled, while remove_extinct will only remove those lineages extinct.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Full documentation","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"reorder!\nrm_stem!\nfixtree!\nremove_extinct\nremove_unsampled","category":"page"},{"location":"man/insane/#Tapestree.INSANE.reorder!","page":"INSANE","title":"Tapestree.INSANE.reorder!","text":"reorder(tree::T) where {T <: iTree}\n\nReorder order of daughter branches according to number of tips, with daughter 1 always having more than daughter 2.\n\n\n\n\n\nreorder!(tree::T, treeda::D) where {T <: iTree, D <: iTree}\n\nReorder order of daughter branches for both trees, following tree first, according to number of tips, with daughter1 always having more than daughter 2.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.rm_stem!","page":"INSANE","title":"Tapestree.INSANE.rm_stem!","text":"rm_stem(tree::T) where {T <: iTree}\n\nRemoves stem branch.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.fixtree!","page":"INSANE","title":"Tapestree.INSANE.fixtree!","text":"fixtree!(tree::T) where {T <: iTree}\n\nFix all tree.\n\n\n\n\n\nfixtree!(tree::T) where {T <: iTf}\n\nFix all tree.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.remove_extinct","page":"INSANE","title":"Tapestree.INSANE.remove_extinct","text":"remove_extinct(tree::T) where {T <: iTree}\n\nRemove extinct tips from iTce.\n\n\n\n\n\nremove_extinct(treev::Vector{T}) where {T <: iTree}\n\nRemove extinct taxa for a vector of trees.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Tapestree.INSANE.remove_unsampled","page":"INSANE","title":"Tapestree.INSANE.remove_unsampled","text":"remove_unsampled(tree::T) where {T <: iTree}\n\nRemove unsampled tips from iTpb.\n\n\n\n\n\nremove_unsampled(treev::Vector{T}) where {T <: iTree}\n\nRemove unsampled taxa for a vector of trees.\n\n\n\n\n\n","category":"function"},{"location":"man/insane/#Insane-plots","page":"INSANE","title":"Insane plots","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Tapestree holds recipes to plot phylogenetic trees, results and perform aggregating functions. The output will rely in the number and type of arguments you provide.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"First, however, we need to load the Plots package","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"using Plots","category":"page"},{"location":"man/insane/#Insane-plots-across-all-tree-types","page":"INSANE","title":"Insane plots across all tree types","text":"","category":"section"},{"location":"man/insane/#Simple-tree-plot","page":"INSANE","title":"Simple tree plot","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"The most basic plot function simply plots the tree:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"One can reorder the tree according to balance (have one daughter always have the largest number of tips) by using reorder!(tree), which orders in place the tree and helps in visualization.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"If one has a tree vector, we could, for example, sample 4 of them at random and simply plot them together using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"ti = rand(tv,4)\n\np0 = plot(ti[1])\np1 = plot(ti[2])\np2 = plot(ti[3])\np3 = plot(ti[4])\n\nplot(p0, p1, p2, p3)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"If the tree is of type sT_label, labels will be shown automatically, but you can toggle this off with showlabels = false.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"One can also plot the tree radially (as a fan) using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(tree, type = :radial)","category":"page"},{"location":"man/insane/#LTT-and-DTT-plots","page":"INSANE","title":"LTT and DTT plots","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can plot the LTT or DTT by using the ltt result (of type Ltt, check (check  Simple tree information)) as input:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(ltt(tree), linewidth = 2.0)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Moreover, if we input a vector of Ltt we will plot each LTT individually, or, better, if we add a decimal number argument, it will use it as sampling frequency through time and return the mean and desired quantiles of lineage or diversity through time using the arguments q0 and q1 (by default q0 = [0.025, 0.975] and q1 = [0.25, 0.75]):","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"lttv = ltt(tv)\nplot(lttv, 0.1)","category":"page"},{"location":"man/insane/#Insane-BDD-and-DBM-plots","page":"INSANE","title":"Insane BDD & DBM plots","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"These plotting functions are specific to BDD or DBM type trees (i.e., of iT or sTxs supertype).","category":"page"},{"location":"man/insane/#Plot-rates-on-the-phylogram","page":"INSANE","title":"Plot rates on the phylogram","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To \"paint\" the tree with the instantaneous lineage-specific rates of speciation lambda(t), we can use:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(tree, birth)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Here, birth, which stands for \"birth rates\", is a convenience wrapper around exp.(lλ(tree)): it extracts the log-speciation vector from a give iT tree using lλ, and then returns the exponential.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"This plotting function also allows to plot the death rates (only where extinction is also a diffusion, i.e., iTbd) using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(tree, death)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"where death, which stands for \"death rates\" is a wrapper around exp.(lμ(tree)).","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"In general, this plotting recipe receives a tree and a function that is applied recursively to paint the tree. Thus, we can use any custom made function that extracts information from the tree. Some predefined ones are:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"logbirth: log-(speciation) birth rates\nlogdeath: log-(extinction) death rates \nturnover: turnover (extinction/speciation) rates\ndiversification: net diversification (speciation - extinction) rates\ntrait: trait values\nevorate: evolutionary rates sigma^2(t)\nlogevorate: log-evolutionary rates sigma^2(t)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can also plot these trees radially using the type = :radial.","category":"page"},{"location":"man/insane/#Plot-the-underlying-rates-along-a-tree","page":"INSANE","title":"Plot the underlying rates along a tree","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To plot how rates evolve across time, that is, to plot the rates in the y axis, we simply change the argument order:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(birth, tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can paint these rates by another variable, say, extinction rates, using","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(birth, tree, zf = death)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Similarly, we can plot the average for a tree (or other aggregating function as median, geometric mean, etc.) and custom quantiles (as in LTT and DTT plots) for a given tree by adding a decimal number argument representing the sampling frequency through time.","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(birth, 0.1, tree)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"To change the aggregating function, we modify the function t_af (by default t_af = mean), to the desired one.","category":"page"},{"location":"man/insane/#Plot-the-rates-across-tree-vectors","page":"INSANE","title":"Plot the rates across tree vectors","text":"","category":"section"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"Often we would like to plot the average rates across a series of data augmented trees. This can be done by adding a decimal number argument (and, using a tree vector as input). For instance, to estimate average speciation rates (using wrapping function birth) through time across tree vector tv, every 01 time units, we use:","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"plot(birth, 0.1, tv)","category":"page"},{"location":"man/insane/","page":"INSANE","title":"INSANE","text":"We can choose the function to aggregate rates across lineages for each single tree using af (by default af = mean, and then to aggregate these tree averages using the vaf function (by default vaf = x -> quantile(x, 0.5), that is, the median).","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/#Installation-of-Julia","page":"Installation","title":"Installation of Julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Download and install: https://julialang.org/downloads/.","category":"page"},{"location":"man/installation/#Installation-of-Tapestree","page":"Installation","title":"Installation of Tapestree","text":"","category":"section"},{"location":"man/installation/#Requirements","page":"Installation","title":"Requirements","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia v1.x\nR installed\nR ape package installed.","category":"page"},{"location":"man/installation/#Installation-2","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Open julia and type the following","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"Tapestree\")","category":"page"}]
}
